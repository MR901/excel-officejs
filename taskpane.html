<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FogLAMP Data Link</title>
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <script type="text/javascript" src="smart-connection.js?v=4"></script>
    <style>
        body { 
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
            font-size: 13px; 
            margin: 0; 
            padding: 0; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
        }
        
        /* 2-section layout */
        .app-body { 
            flex: 1 1 auto; 
            overflow-y: auto; 
            padding: 12px; 
        }
        .app-console { 
            flex: 0 0 var(--console-height, 28px); 
            background: #0b0f17; 
            border-top: 1px solid #232b3a; 
            position: relative; 
        }
        
        
        /* Content sections */
        details { border: 1px solid #e1e4e8; border-radius: 6px; padding: 8px 10px; background: #fff; margin-bottom: 10px; }
        summary { font-weight: 600; cursor: pointer; outline: none; }
        summary::-webkit-details-marker { display: none; }
        .section-content { margin-top: 8px; }
        .row { margin-bottom: 8px; }
        .row label { font-weight: 600; }
        
        /* Form elements */
        input[type="text"], input[type="number"], select { width: 100%; box-sizing: border-box; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        button { padding: 6px 10px; border: 1px solid #d0d7de; background: #f6f8fa; border-radius: 6px; cursor: pointer; }
        button:hover { background: #eef1f4; }
        .btn-row > button { margin-right: 6px; }
        
        /* Utilities */
        .muted { color: #57606a; }
        .info { display:inline-flex; align-items:flex-start; margin-left: 4px; cursor: help; color: #9ca3af; font-size: 11px; line-height: 1; vertical-align: top; }
        .info img { height: 10px; width: 10px; opacity: 0.8; margin-bottom: 4px; margin-top: 1px; }
        .stack { display: flex; gap: 8px; flex-wrap: wrap; }
        .stack > * { flex: 1 1 auto; }
        .small { font-size: 12px; }
        .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
        .live-badge { display: inline-block; background: #16a34a; color: #ffffff; border-radius: 999px; padding: 2px 8px; font-size: 11px; margin-left: 8px; vertical-align: middle; }

        /* Enhanced UI Components */
        .badge { 
            display: inline-block; 
            padding: 4px 8px; 
            border-radius: 999px; 
            font-size: 11px; 
            font-weight: 500;
            background: #eef2ff; 
            color: #3730a3; 
            border: 1px solid #c7d2fe;
            margin-right: 6px;
        }
        .badge.active { background: #dcfce7; color: #166534; border-color: #bbf7d0; }
        .badge.warning { background: #fef3c7; color: #92400e; border-color: #fde68a; }
        .badge.error { background: #fee2e2; color: #dc2626; border-color: #fecaca; }
        .badge.success { background: #dcfce7; color: #166534; border-color: #bbf7d0; }

        .status-dot { 
            display: inline-block; 
            width: 8px; 
            height: 8px; 
            border-radius: 50%; 
            margin-right: 6px; 
            flex-shrink: 0;
        }
        .status-dot.success { background: #16a34a; }
        .status-dot.failed { background: #dc2626; }
        .status-dot.checking { background: #f59e0b; animation: pulse 1s infinite; }
        .status-dot.unknown { background: #9ca3af; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .instance-row { 
            display: flex; 
            align-items: center; 
            padding: 8px 12px; 
            border: 1px solid #e5e7eb; 
            border-radius: 6px; 
            margin-bottom: 6px;
            background: #ffffff;
        }
        .instance-row.active { 
            background: #f0f9ff; 
            border-color: #0ea5e9; 
        }
        .instance-info { 
            flex: 1; 
            min-width: 0; 
        }
        .instance-name { 
            font-weight: 600; 
            margin-bottom: 2px;
            color: #111827;
        }
        .instance-url { 
            font-size: 11px; 
            color: #6b7280; 
            word-break: break-all;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }
        .instance-actions { 
            display: flex; 
            gap: 4px; 
            margin-left: 8px;
        }
        .instance-actions button { 
            padding: 4px 8px; 
            font-size: 11px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            color: #374151;
        }
        .instance-actions button:hover { 
            background: #f3f4f6; 
        }
        .instance-actions button.primary { 
            background: #2563eb; 
            color: white; 
            border-color: #2563eb;
        }
        .instance-actions button.primary:hover { 
            background: #1d4ed8; 
        }

        .feedback-area { 
            margin-top: 6px; 
            padding: 6px 8px; 
            border-radius: 4px; 
            font-size: 12px;
            display: none;
        }
        .feedback-area.success { 
            background: #dcfce7; 
            color: #166534; 
            border: 1px solid #bbf7d0;
        }
        .feedback-area.warning { 
            background: #fef3c7; 
            color: #92400e; 
            border: 1px solid #fde68a;
        }
        .feedback-area.error { 
            background: #fee2e2; 
            color: #dc2626; 
            border: 1px solid #fecaca;
        }

        .empty-state { 
            text-align: center; 
            padding: 24px 12px; 
            color: #9ca3af; 
            font-style: italic;
        }
        
        /* Console styling */
        .console-resizer { 
            height: 3px; 
            cursor: ns-resize; 
            background: #374151; 
            border-top: 1px solid #4b5563;
            transition: background-color 0.15s ease;
        }
        .console-resizer:hover { background: #6b7280; }
        .console-header { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 4px 12px; 
            color: #e5e7eb; 
            background: #1f2937; 
            height: 24px;
            box-sizing: border-box;
        }
        .console-title { font-weight: 600; font-size: 11px; }
        .console-content { 
            height: calc(var(--console-height, 28px) - 28px); 
            overflow-y: auto; 
            padding: 6px 12px; 
            background: #0b0f17; 
        }
        .status-pre { 
            white-space: pre-wrap; 
            background: #0b0f17; 
            color: #f5f5f5; 
            padding: 0; 
            border: none; 
            border-radius: 0; 
            min-height: auto; 
            max-height: none; 
            overflow: visible; 
            margin: 0; 
            font-size: 11px; 
            line-height: 1.4; 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }
        
        /* Summary in main content (not console) */
        details .status-pre {
            background: #f8f9fa;
            color: #212529;
            border: 1px solid #dee2e6;
        }
    </style>
</head>

<body>
    <!-- Scrollable Interaction Area -->
    <div class="app-body">
        <!-- Overview / Connection Status -->
        <details open>
            <summary>Overview</summary>
        <div class="section-content">
                <div class="row" style="margin-bottom: 12px;">
                    <div id="environment-badge" class="badge">Detecting...</div>
                    <div id="connectivity-badge" class="badge">Checking...</div>
                    <div id="proxy-badge" class="badge">Unknown</div>
                </div>
                <div class="row" style="margin-bottom: 12px;">
                    <div id="active-instance-display" class="small muted">No active instance</div>
                </div>
            <div class="row">
                <div class="stack">
                    <button id="refresh-connections" type="button" title="Re-scan all instances and update status">Refresh Status</button>
                    <button id="reset-connections" type="button" title="Reset all connections and force complete re-discovery">Reset Connections</button>
                </div>
            </div>
                <div id="proxy-guidance" class="feedback-area warning" style="display: none;">
                    <strong>ðŸ’¡ Excel Web detected:</strong> Run <code>node simple-proxy.js</code> locally to access private network instances.
            </div>
        </div>
    </details>

        <!-- FogLAMP Instances (Merged) -->
    <details open>
            <summary>FogLAMP Instances</summary>
        <div class="section-content">
                <!-- Add Instance -->
            <div class="row">
                    <label for="fl-base-url">Add Instance <span class="info" title="Enter FogLAMP URL (e.g., http://127.0.0.1:8081)"><img src="icons/info-icon-16.png" alt="info" /></span></label>
                <div class="stack">
                        <input id="fl-base-url" type="text" placeholder="http://127.0.0.1:8081" />
                        <button id="fl-register" type="button" title="Validate and add this FogLAMP instance">Add</button>
                    </div>
                </div>
                
                <!-- Adaptive Add Feedback -->
                <div id="fl-add-feedback" class="feedback-area" style="display: none;"></div>
                <div id="fl-add-actions" class="row" style="display: none; gap: 6px; margin-top: 6px;">
                    <button id="fl-add-confirm" type="button" class="primary">Add</button>
                    <button id="fl-add-skip" type="button">Skip</button>
            </div>

                <!-- Instance List -->
                <div class="row" style="margin-top: 16px;">
                    <div id="instances-container">
                        <div class="empty-state" id="empty-instances">
                            No instances yet. Add a FogLAMP URL to begin.
                        </div>
                    </div>
                </div>

                <!-- Instance Actions Summary -->
                <div class="row" style="margin-top: 12px;">
            <details>
                        <summary>Instance Summary</summary>
                <div class="section-content">
                    <div class="row">
                                <button id="fl-check-summary" type="button" title="Get comprehensive status (ping + statistics + assets) for active instance">Get Active Instance Details</button>
                    </div>
                    <pre id="fl-summary" class="status-pre"></pre>
                </div>
            </details>
                </div>
        </div>
    </details>

        <!-- Data Actions -->
    <details>
            <summary>Data Actions <span class="muted small">(Excel export)</span></summary>
        <div class="section-content">
                <div class="stack" style="margin-bottom: 12px;">
                    <!-- Export Status -->
                    <div style="border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px;">
            <div class="row">
                            <strong>Export Status</strong>
                            <div class="small muted">Ping, statistics, assets â†’ formatted sheet</div>
            </div>
                        <div class="row">
                            <button id="fl-write-status" type="button" title="Export comprehensive status to Excel sheet">Export Status to Sheet</button>
        </div>
                    </div>

                    <!-- Export Asset Readings -->
                    <div style="border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px;">
            <div class="row">
                            <strong>Export Asset Readings</strong>
                            <div class="small muted">Asset data â†’ formatted sheet</div>
            </div>
            <div class="row">
                            <div class="stack">
                                <select id="fl-asset-select" title="Select asset from available assets">
                                    <option value="">Loading assets...</option>
                                </select>
                                <input id="fl-asset" type="text" placeholder="or type asset name" />
                            </div>
            </div>
            <div class="row">
                            <div class="stack">
                                <input id="fl-datapoint" type="text" placeholder="datapoint (optional)" />
                                <input id="fl-limit" type="number" min="1" max="10000" value="100" placeholder="limit" style="max-width: 100px;" />
                            </div>
            </div>
            <div class="row">
                            <input id="fl-skip" type="number" min="0" value="0" placeholder="skip (pagination)" style="max-width: 120px;" />
            </div>
            <div class="row">
                            <label class="small">Time window (use only one)</label>
                <div class="stack">
                    <input id="fl-seconds" type="number" min="1" placeholder="seconds" />
                    <input id="fl-minutes" type="number" min="1" placeholder="minutes" />
                    <input id="fl-hours" type="number" min="1" placeholder="hours" />
                </div>
            </div>
            <div class="row">
                            <input id="fl-previous" type="number" min="1" placeholder="previous (for historical)" />
            </div>
            <div class="row">
                            <button id="fl-get-readings" type="button" title="Export asset readings to Excel sheet">Get Readings</button>
            </div>
        </div>
                </div>
            </div>
        </details>
    </div>

    <!-- Draggable Console -->
    <div class="app-console">
        <div class="console-resizer" title="Drag to resize console"></div>
        <div class="console-header">
            <div class="console-title">Console <span class="muted small">live logs & messages</span></div>
            <div>
                <button id="clear-console" style="background: transparent; border: 1px solid #4b5563; color: #e5e7eb; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; margin-right: 8px;" title="Clear console logs">Clear</button>
            <span class="live-badge" title="Status updates appear here in real time">LIVE</span>
            </div>
        </div>
        <div class="console-content">
            <pre id="fl-status" class="status-pre"></pre>
        </div>
    </div>
    <script>
        // Initialize Office.js
        Office.onReady(function (info) { });

        // Add a click event listener to the button
        document.getElementById("run-btn") && document.getElementById("run-btn").addEventListener("click", run);

        // Based on 'Basic API call' sample from ScriptLab
        async function run() {
            await Excel.run(async (context) => {
                const range = context.workbook.getSelectedRange();
                range.format.fill.color = "yellow";
                range.load("address");

                await context.sync();

                const sheets = context.workbook.worksheets;
                sheets.getItem("Sheet1").getRange("A1").values = [["The selected address was " + range.address + "."]];
            });
        }

        // =============================
        // FogLAMP DataLink prototype JS
        // =============================

        const STORAGE_KEYS = {
            INSTANCES: "FOGLAMP_INSTANCES",
            ACTIVE: "FOGLAMP_ACTIVE"
        };

        /**
         * Enhanced UI element selectors
         * Maps to the new redesigned interface components
         */
        const els = {
            // Overview badges
            environmentBadge: () => document.getElementById("environment-badge"),
            connectivityBadge: () => document.getElementById("connectivity-badge"),
            proxyBadge: () => document.getElementById("proxy-badge"),
            activeInstanceDisplay: () => document.getElementById("active-instance-display"),
            refreshConnections: () => document.getElementById("refresh-connections"),
            resetConnections: () => document.getElementById("reset-connections"),
            proxyGuidance: () => document.getElementById("proxy-guidance"),

            // Add instance form
            baseUrl: () => document.getElementById("fl-base-url"),
            register: () => document.getElementById("fl-register"),
            addFeedback: () => document.getElementById("fl-add-feedback"),
            addActions: () => document.getElementById("fl-add-actions"),
            addConfirm: () => document.getElementById("fl-add-confirm"),
            addSkip: () => document.getElementById("fl-add-skip"),

            // Instance management
            instancesContainer: () => document.getElementById("instances-container"),
            emptyInstances: () => document.getElementById("empty-instances"),
            checkSummary: () => document.getElementById("fl-check-summary"),
            summary: () => document.getElementById("fl-summary"),

            // Data actions
            writeStatus: () => document.getElementById("fl-write-status"),
            assetSelect: () => document.getElementById("fl-asset-select"),
            asset: () => document.getElementById("fl-asset"),
            datapoint: () => document.getElementById("fl-datapoint"),
            limit: () => document.getElementById("fl-limit"),
            skip: () => document.getElementById("fl-skip"),
            seconds: () => document.getElementById("fl-seconds"),
            minutes: () => document.getElementById("fl-minutes"),
            hours: () => document.getElementById("fl-hours"),
            previous: () => document.getElementById("fl-previous"),
            getReadings: () => document.getElementById("fl-get-readings"),

            // Console
            status: () => document.getElementById("fl-status")
        };

        // Enhanced Instance Storage System
        // =================================
        // This system manages both URL list (for backward compatibility) 
        // and rich metadata for each instance

        /**
         * Utility function to safely extract display name from instance
         * @param {Object} instance - Instance metadata object
         * @returns {string} Safe display name
         */
        function getDisplayName(instance) {
            if (instance.name) return instance.name;
            if (instance.hostName) return instance.hostName;
            
            try {
                return new URL(instance.url).hostname;
            } catch (e) {
                // Fallback parsing for malformed URLs
                return instance.url.replace(/^https?:\/\//, '').split('/')[0] || 'Unknown Instance';
            }
        }

        /**
         * Storage key constants
         */
        const ENHANCED_STORAGE_KEYS = {
            ...STORAGE_KEYS,
            INSTANCE_METADATA: 'foglamp_instance_metadata'
        };

        /**
         * Status constants to prevent inconsistencies
         */
        const INSTANCE_STATUS = {
            SUCCESS: 'success',
            FAILED: 'failed', 
            CHECKING: 'checking',
            UNKNOWN: 'unknown'
        };

        /**
         * Instance metadata structure:
         * {
         *   url: string,
         *   name?: string,           // Optional user-provided name
         *   hostName?: string,       // From FogLAMP /ping response
         *   lastStatus: 'success'|'failed'|'checking'|'unknown',
         *   lastPingMs?: number,     // Response time in milliseconds
         *   lastCheckedAt?: string,  // ISO timestamp
         *   addedAt: string,         // ISO timestamp when first added
         *   lastError?: string       // Last error message if any
         * }
         */

        /**
         * Get all instance metadata
         * @returns {Object} Map of URL -> metadata
         */
        function getInstanceMetadata() {
            try {
                const raw = localStorage.getItem(ENHANCED_STORAGE_KEYS.INSTANCE_METADATA);
                return raw ? JSON.parse(raw) : {};
            } catch (e) {
                console.warn('Failed to parse instance metadata:', e);
                return {};
            }
        }

        /**
         * Save instance metadata map
         * @param {Object} metadataMap - Map of URL -> metadata
         */
        function saveInstanceMetadata(metadataMap) {
            try {
                localStorage.setItem(ENHANCED_STORAGE_KEYS.INSTANCE_METADATA, JSON.stringify(metadataMap));
            } catch (e) {
                console.error('Failed to save instance metadata:', e);
            }
        }

        /**
         * Get metadata for specific instance
         * @param {string} url - Instance URL
         * @returns {Object} Instance metadata or default structure
         */
        function getInstanceMeta(url) {
            const allMeta = getInstanceMetadata();
            return allMeta[url] || {
                url,
                lastStatus: 'unknown',
                addedAt: new Date().toISOString()
            };
        }

        /**
         * Update metadata for specific instance
         * @param {string} url - Instance URL
         * @param {Object} updates - Partial metadata updates
         */
        function updateInstanceMeta(url, updates) {
            const allMeta = getInstanceMetadata();
            allMeta[url] = {
                ...getInstanceMeta(url),
                ...updates,
                url // Ensure URL is always present
            };
            saveInstanceMetadata(allMeta);
        }

        /**
         * Get enhanced instance list with metadata
         * @returns {Array} Array of enhanced instance objects
         */
        function getEnhancedInstances() {
            const urls = getInstances();
            const metadata = getInstanceMetadata();
            return urls.map(url => ({
                ...getInstanceMeta(url),
                url
            }));
        }

        // Legacy Storage Functions (Maintain Compatibility)
        // ================================================

        /**
         * Get instance URLs (legacy compatibility)
         * @returns {Array<string>} Array of instance URLs
         */
        function getInstances() {
            try {
                const raw = localStorage.getItem(STORAGE_KEYS.INSTANCES);
                return raw ? JSON.parse(raw) : [];
            } catch (e) {
                console.warn('Failed to parse instances:', e);
                return [];
            }
        }

        /**
         * Save instance URLs (legacy compatibility)
         * @param {Array<string>} instances - Array of URLs
         */
        function saveInstances(instances) {
            try {
            localStorage.setItem(STORAGE_KEYS.INSTANCES, JSON.stringify(instances));
            } catch (e) {
                console.error('Failed to save instances:', e);
            }
        }

        /**
         * Add new instance with enhanced metadata support
         * @param {string} baseUrl - Instance URL
         * @param {Object} options - Additional options (name, hostName, etc.)
         * @returns {boolean} Success status
         */
        function addInstance(baseUrl, options = {}) {
            const url = normalizeBaseUrl(baseUrl);
            if (!url) return false;

            const instances = getInstances();
            const isNew = !instances.includes(url);
            
            if (isNew) {
                instances.push(url);
                saveInstances(instances);
                
                // Initialize metadata for new instance
                updateInstanceMeta(url, {
                    name: options.name,
                    hostName: options.hostName,
                    lastStatus: options.lastStatus || 'unknown',
                    lastPingMs: options.lastPingMs,
                    addedAt: new Date().toISOString()
                });
            }

            // Set as active by default when added
            localStorage.setItem(STORAGE_KEYS.ACTIVE, url);
            return isNew;
        }

        /**
         * Remove instance and its metadata
         * @param {string} url - Instance URL to remove
         * @returns {boolean} Success status
         */
        function removeInstance(url) {
            const instances = getInstances();
            const filteredInstances = instances.filter(u => u !== url);
            
            if (filteredInstances.length !== instances.length) {
                saveInstances(filteredInstances);
                
                // Remove metadata
                const metadata = getInstanceMetadata();
                delete metadata[url];
                saveInstanceMetadata(metadata);
                
                // Clear active if removing active instance
                if (getActiveInstance() === url) {
                    const nextActive = filteredInstances.length > 0 ? filteredInstances[0] : null;
                    if (nextActive) {
                        setActiveInstance(nextActive);
                    } else {
                        localStorage.removeItem(STORAGE_KEYS.ACTIVE);
                    }
                }
                
            return true;
            }
            return false;
        }

        /**
         * Get active instance URL
         * @returns {string|null} Active instance URL
         */
        function getActiveInstance() {
            const active = localStorage.getItem(STORAGE_KEYS.ACTIVE);
            if (active && getInstances().includes(active)) {
                return active;
            }
            
            // Fallback to first available instance
            const instances = getInstances();
            const fallback = instances.length > 0 ? instances[0] : null;
            if (fallback) {
                setActiveInstance(fallback);
            }
            return fallback;
        }

        /**
         * Set active instance
         * @param {string} url - Instance URL to set as active
         */
        function setActiveInstance(url) {
            if (getInstances().includes(url)) {
            localStorage.setItem(STORAGE_KEYS.ACTIVE, url);
            } else {
                console.warn('Attempted to set non-existent instance as active:', url);
            }
        }

        /**
         * Get active instance with metadata
         * @returns {Object|null} Enhanced active instance object
         */
        function getActiveInstanceWithMeta() {
            const activeUrl = getActiveInstance();
            return activeUrl ? getInstanceMeta(activeUrl) : null;
        }

        // Make core functions globally available for smart-connection.js and debugging
        window.getInstances = getInstances;
        window.addInstance = addInstance;
        window.removeInstance = removeInstance;
        window.getActiveInstance = getActiveInstance;
        window.setActiveInstance = setActiveInstance;
        window.saveInstances = saveInstances;
        
        // Enhanced metadata functions
        window.getEnhancedInstances = getEnhancedInstances;
        window.getInstanceMeta = getInstanceMeta;
        window.updateInstanceMeta = updateInstanceMeta;
        window.getActiveInstanceWithMeta = getActiveInstanceWithMeta;

        // Enhanced UI Management Functions
        // ===============================

        /**
         * Update overview badges with current system status
         */
        function updateOverviewBadges() {
            const environment = window.smartManager?.environment || 'unknown';
            const proxy = window.smartManager?.proxyAvailable || false;
            const instances = getEnhancedInstances();
            const reachableCount = instances.filter(i => i.lastStatus === 'success').length;
            
            // Debug logging for status calculation
            if (instances.length > 0) {
                const statusBreakdown = instances.reduce((acc, inst) => {
                    acc[inst.lastStatus || 'unknown'] = (acc[inst.lastStatus || 'unknown'] || 0) + 1;
                    return acc;
                }, {});
                console.log(`ðŸ” Status calculation: ${reachableCount}/${instances.length} connected`, statusBreakdown);
            }
            
            // Environment badge
            const envBadge = els.environmentBadge();
            if (envBadge) {
                envBadge.textContent = environment === 'web' ? 'Excel Web' : 
                                     environment === 'desktop' ? 'Excel Desktop' : 'Unknown';
                envBadge.className = `badge ${environment === 'web' ? 'warning' : 'success'}`;
            }

            // Connectivity badge with enhanced status handling
            const connBadge = els.connectivityBadge();
            if (connBadge) {
                const total = instances.length;
                if (total === 0) {
                    connBadge.textContent = 'No instances';
                    connBadge.className = 'badge error';
                } else if (reachableCount === total) {
                    connBadge.textContent = `All ${total} connected`;
                    connBadge.className = 'badge success';
                } else if (reachableCount > 0) {
                    connBadge.textContent = `${reachableCount} of ${total} connected`;
                    connBadge.className = 'badge warning';
                } else {
                    connBadge.textContent = `0 of ${total} connected`;
                    connBadge.className = 'badge error';
                }
            }

            // Proxy badge with scenario-specific handling
            const proxyBadge = els.proxyBadge();
            if (proxyBadge) {
                if (environment === 'desktop') {
                    proxyBadge.textContent = 'N/A';
                    proxyBadge.className = 'badge default';
                } else {
                    // Web environment
                    proxyBadge.textContent = proxy ? 'Proxy: Running' : 'Proxy: Not Running';
                    proxyBadge.className = `badge ${proxy ? 'success' : 'warning'}`;
                }
            }

            // Active instance display with enhanced messages
            const activeDisplay = els.activeInstanceDisplay();
            if (activeDisplay) {
                const active = getActiveInstanceWithMeta();
                if (active) {
                    const displayName = active.name || active.hostName || new URL(active.url).hostname;
                    activeDisplay.textContent = `Active: ${displayName}`;
                    activeDisplay.className = 'small';
                } else if (instances.length === 0) {
                    activeDisplay.textContent = 'Add instances to get started';
                    activeDisplay.className = 'small muted';
                } else {
                    activeDisplay.textContent = 'No active instance - click "Set Active"';
                    activeDisplay.className = 'small muted';
                }
            }

            // Enhanced proxy guidance logic
            const guidance = els.proxyGuidance();
            if (guidance) {
                // Only show for web environment with no proxy AND non-localhost instances exist
                const hasRemoteInstances = instances.some(i => 
                    !i.url.includes('127.0.0.1') && !i.url.includes('localhost')
                );
                const shouldShow = environment === 'web' && !proxy && hasRemoteInstances;
                guidance.style.display = shouldShow ? 'block' : 'none';
            }
        }

        /**
         * Render enhanced instance list with metadata and actions
         */
        function renderInstanceList() {
            const container = els.instancesContainer();
            const emptyState = els.emptyInstances();
            if (!container || !emptyState) return;

            const instances = getEnhancedInstances();
            const activeUrl = getActiveInstance();

            // Clear container
            container.innerHTML = '';

            if (instances.length === 0) {
                container.appendChild(emptyState);
                return;
            }

            // Sort instances: Active first, then successful (by ping time), then failed
            const sortedInstances = [...instances].sort((a, b) => {
                if (a.url === activeUrl) return -1;
                if (b.url === activeUrl) return 1;
                if (a.lastStatus === 'success' && b.lastStatus !== 'success') return -1;
                if (b.lastStatus === 'success' && a.lastStatus !== 'success') return 1;
                if (a.lastStatus === 'success' && b.lastStatus === 'success') {
                    return (a.lastPingMs || 999999) - (b.lastPingMs || 999999);
                }
                return a.url.localeCompare(b.url);
            });

            // Render each instance
            sortedInstances.forEach(instance => {
                const row = document.createElement('div');
                row.className = `instance-row ${instance.url === activeUrl ? 'active' : ''}`;

                // Status dot
                const dot = document.createElement('div');
                dot.className = `status-dot ${instance.lastStatus || 'unknown'}`;

                // Instance info
                const info = document.createElement('div');
                info.className = 'instance-info';

                const name = document.createElement('div');
                name.className = 'instance-name';
                name.textContent = getDisplayName(instance);
                
                // Add editable name functionality
                name.addEventListener('dblclick', () => editInstanceName(instance.url, name));

                const url = document.createElement('div');
                url.className = 'instance-url';
                url.textContent = instance.url;

                info.appendChild(name);
                info.appendChild(url);

                // Action buttons
                const actions = document.createElement('div');
                actions.className = 'instance-actions';

                // Active badge for active instance
                if (instance.url === activeUrl) {
                    const activeBadge = document.createElement('span');
                    activeBadge.className = 'badge active';
                    activeBadge.textContent = 'Active';
                    activeBadge.style.marginRight = '8px';
                    actions.appendChild(activeBadge);
                }

                // Ping time badge
                if (instance.lastPingMs) {
                    const pingBadge = document.createElement('span');
                    pingBadge.className = 'small muted';
                    pingBadge.textContent = `${instance.lastPingMs}ms`;
                    pingBadge.style.marginRight = '8px';
                    actions.appendChild(pingBadge);
                }

                // Action buttons
                if (instance.url !== activeUrl) {
                    const setActiveBtn = document.createElement('button');
                    setActiveBtn.textContent = 'Set Active';
                    setActiveBtn.className = 'primary';
                    setActiveBtn.onclick = () => setInstanceActive(instance.url);
                    actions.appendChild(setActiveBtn);
                }

                const pingBtn = document.createElement('button');
                pingBtn.textContent = 'Ping';
                pingBtn.onclick = () => pingInstance(instance.url);
                actions.appendChild(pingBtn);

                // Removed confusing per-instance Statistics button - use main "Get Summary" instead

                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => removeInstanceWithConfirm(instance.url);
                actions.appendChild(removeBtn);

                // Assemble row
                row.appendChild(dot);
                row.appendChild(info);
                row.appendChild(actions);

                container.appendChild(row);
            });
        }

        /**
         * Edit instance name inline
         * @param {string} url - Instance URL
         * @param {Element} nameElement - Name element to edit
         */
        function editInstanceName(url, nameElement) {
            const currentName = getInstanceMeta(url).name || '';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.width = '100%';
            input.style.fontSize = '14px';
            input.style.fontWeight = '600';

            const save = () => {
                const newName = input.value.trim();
                updateInstanceMeta(url, { name: newName });
                renderInstanceList();
                updateOverviewBadges();
                logMessage('info', 'Instance name updated', { url, name: newName || '(cleared)' });
            };

            const cancel = () => {
                renderInstanceList();
            };

            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') save();
                if (e.key === 'Escape') cancel();
            });

            nameElement.replaceWith(input);
            input.focus();
            input.select();
        }

        // Console Logging System
        // =====================

        /**
         * Log structured message to console with enhanced UI features
         * @param {string} level - Log level: 'info', 'warn', 'error'
         * @param {string} message - Log message
         * @param {Object} details - Optional details object
         */
        function logMessage(level, message, details = null) {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${level.toUpperCase()}]`;
            const fullMessage = `${timestamp} ${prefix} ${message}`;
            
            // Log to browser console
            const consoleMethod = level === 'error' ? 'error' : (level === 'warn' ? 'warn' : 'log');
            if (details) {
                console[consoleMethod](`${fullMessage}`, details);
            } else {
                console[consoleMethod](fullMessage);
            }
            
            // Log to UI console with enhanced formatting
            const statusElement = els.status();
            if (statusElement) {
                const logLine = details ? 
                    `${fullMessage} ${JSON.stringify(details)}` : 
                    fullMessage;
                
                // Add visual separator for new messages
                if (statusElement.textContent.trim()) {
                    statusElement.textContent += '\n';
                }
                
                // Add the log line with level-based formatting
                statusElement.textContent += `ðŸ”¹ ${logLine}`;
                
                // Auto-scroll to bottom with smooth animation
                statusElement.scrollTop = statusElement.scrollHeight;
                
                // Briefly highlight the new entry
                statusElement.style.borderColor = level === 'error' ? '#dc2626' : (level === 'warn' ? '#f59e0b' : '#16a34a');
                setTimeout(() => {
                    statusElement.style.borderColor = '#374151';
                }, 1000);
            }
        }

        /**
         * Clear console logs
         */
        function clearConsole() {
            const statusElement = els.status();
            if (statusElement) {
                statusElement.textContent = '';
                logMessage('info', 'Console cleared');
            }
        }

        // Instance Management Functions
        // ============================

        /**
         * Ping specific instance and update its status
         * @param {string} url - Instance URL to ping
         */
        async function pingInstance(url) {
            updateInstanceMeta(url, { lastStatus: 'checking' });
            renderInstanceList();
            
            const startTime = performance.now();
            logMessage('info', 'Ping started', { url });

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(`${url}/foglamp/ping`, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                clearTimeout(timeoutId);
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                
                if (response.ok) {
                    const data = await response.json();
                    updateInstanceMeta(url, {
                        lastStatus: 'success',
                        lastPingMs: pingMs,
                        lastCheckedAt: new Date().toISOString(),
                        hostName: data.hostName || getInstanceMeta(url).hostName,
                        lastError: null // Clear previous errors on success
                    });
                    logMessage('info', `Individual ping SUCCESS: ${url} (${pingMs}ms)`, data);
                } else {
                    updateInstanceMeta(url, {
                        lastStatus: 'failed',
                        lastPingMs: pingMs,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: `HTTP ${response.status}`
                    });
                    logMessage('warn', `Individual ping FAILED: ${url} (HTTP ${response.status})`);
                }
            } catch (error) {
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                updateInstanceMeta(url, {
                    lastStatus: 'failed',
                    lastPingMs: null, // No meaningful ping time for network errors
                    lastCheckedAt: new Date().toISOString(),
                    lastError: error.message
                });
                logMessage('warn', `Individual ping NETWORK ERROR: ${url} (${error.message})`);
            }
            
            renderInstanceList();
            updateOverviewBadges();
            
            // ðŸ”§ CRITICAL FIX: Sync individual ping results with smart connection manager
            // This prevents the dual status system desync bug where individual ping works
            // but Get Summary/Export functions fail due to smart manager thinking instances are inaccessible
            await syncToSmartManager();
        }

        /**
         * Set instance as active
         * @param {string} url - Instance URL to set as active
         */
        async function setInstanceActive(url) {
            setActiveInstance(url);
            logMessage('info', 'Active instance changed', { url });
            renderInstanceList();
            updateOverviewBadges();
            
            // Load assets for the new active instance
            await loadAssetsForActiveInstance();
        }

        /**
         * Remove instance with confirmation
         * @param {string} url - Instance URL to remove
         */
        function removeInstanceWithConfirm(url) {
            const instance = getInstanceMeta(url);
            const displayName = getDisplayName(instance);
            
            logMessage('info', 'Remove requested', { url, displayName });
            
            if (confirm(`Remove instance "${displayName}"?\n\nURL: ${url}`)) {
                const removed = removeInstance(url);
                if (removed) {
                    logMessage('info', 'Instance removed successfully', { url, name: displayName });
                    renderInstanceList();
                    updateOverviewBadges();
                } else {
                    logMessage('warn', 'Failed to remove instance', { url });
                }
            } else {
                logMessage('info', 'Remove cancelled by user', { url });
            }
        }

        /**
         * Get statistics for specific instance with proper error handling
         * @param {string} url - Instance URL
         */
        async function getInstanceStatistics(url) {
            logMessage('info', 'Fetching statistics', { url });
            
            try {
                // Set as active temporarily to use smart API functions
                const originalActive = getActiveInstance();
                setActiveInstance(url);
                
                const stats = await foglampStatisticsSmart();
                
                // Display in summary area
                const summaryElement = els.summary();
                if (summaryElement) {
                    updateSummary(summaryElement, { statistics: stats });
                }
                
                // Restore original active
                if (originalActive && originalActive !== url) {
                    setActiveInstance(originalActive);
                    renderInstanceList();
                }
                
                logMessage('info', 'Statistics retrieved successfully', { url });
                
            } catch (error) {
                logMessage('error', 'Failed to get statistics', { url, error: error.message });
                
                // Display error in summary area
                const summaryElement = els.summary();
                if (summaryElement) {
                    updateSummary(summaryElement, { 
                        error: `Statistics failed for ${url}: ${error.message}` 
                    });
                }
                
                // Update main status
                updateStatus('Statistics failed:', { error: error.message });
            }
        }

        /**
         * Enhanced asset readings API call with all parameters
         * @param {Object} params - API parameters object
         * @returns {Promise} Asset readings data
         */
        async function foglampAssetReadingsSmartWithParams(params) {
            // Use the existing smart API but with all the parameters
            return await foglampAssetReadingsSmart(
                params.asset,
                params.datapoint,
                params.limit,
                params.skip,
                params.seconds,
                params.minutes, 
                params.hours,
                params.previous
            );
        }

        // Adaptive Add Flow Implementation
        // ===============================

        /**
         * Show add feedback message
         * @param {string} message - Feedback message
         * @param {string} type - Message type: 'success', 'warning', 'error'
         */
        function showAddFeedback(message, type = 'success') {
            const feedback = els.addFeedback();
            if (feedback) {
                feedback.textContent = message;
                feedback.className = `feedback-area ${type}`;
                feedback.style.display = 'block';
            }
        }

        /**
         * Hide add feedback
         */
        function hideAddFeedback() {
            const feedback = els.addFeedback();
            if (feedback) {
                feedback.style.display = 'none';
            }
        }

        /**
         * Show/hide add action buttons
         * @param {boolean} show - Whether to show buttons
         * @param {string} url - URL being added
         * @param {Object} pingResult - Ping result data
         */
        function toggleAddActions(show, url = '', pingResult = null) {
            const actions = els.addActions();
            const confirmBtn = els.addConfirm();
            const skipBtn = els.addSkip();
            
            if (!actions || !confirmBtn || !skipBtn) return;
            
            actions.style.display = show ? 'flex' : 'none';
            
            if (show) {
                // Configure confirm button
                confirmBtn.onclick = async () => {
                    await confirmAddInstance(url, pingResult);
                    hideAddFeedback();
                    toggleAddActions(false);
                };
                
                // Configure skip button
                skipBtn.onclick = () => {
                    logMessage('info', 'Add skipped', { url });
                    hideAddFeedback();
                    toggleAddActions(false);
                };
            }
        }

        /**
         * Confirm and add instance with metadata
         * @param {string} url - Instance URL
         * @param {Object} pingResult - Ping result data
         */
        async function confirmAddInstance(url, pingResult) {
            const options = {
                lastStatus: pingResult?.ok ? 'success' : 'failed',
                lastPingMs: pingResult?.pingMs,
                hostName: pingResult?.data?.hostName,
                lastCheckedAt: new Date().toISOString()
            };
            
            const added = addInstance(url, options);
            
            if (added) {
                logMessage('info', 'Instance added successfully', { 
                    url, 
                    hostName: options.hostName,
                    status: options.lastStatus 
                });
                
                // Clear input
                const input = els.baseUrl();
                if (input) input.value = '';
                
                // Update UI
                renderInstanceList();
                updateOverviewBadges();
                
                // Load assets for new active instance
                await loadAssetsForActiveInstance();
            } else {
                logMessage('warn', 'Instance already exists', { url });
            }
        }

        /**
         * Ping URL with timeout for validation
         * @param {string} url - URL to ping
         * @param {number} timeoutMs - Timeout in milliseconds
         * @returns {Promise} Ping result
         */
        async function pingUrlForValidation(url, timeoutMs = 3000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            const startTime = performance.now();
            
            try {
                const response = await fetch(`${url}/foglamp/ping`, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    return { ok: true, pingMs, data, status: response.status };
                } else {
                    return { ok: false, pingMs, status: response.status };
                }
            } catch (error) {
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                clearTimeout(timeoutId);
                return { ok: false, pingMs, error: error.message };
            }
        }

        // Asset Management Functions
        // =========================

        /**
         * Load assets for the active instance
         */
        async function loadAssetsForActiveInstance() {
            const assetSelect = els.assetSelect();
            if (!assetSelect) return;

            const activeInstance = getActiveInstance();
            if (!activeInstance) {
                assetSelect.innerHTML = '<option value="">No active instance</option>';
                return;
            }

            assetSelect.innerHTML = '<option value="">Loading assets...</option>';
            
            try {
                const assets = await foglampAssetsSmart();
                
                // Clear and populate dropdown
                assetSelect.innerHTML = '<option value="">Select asset...</option>';
                
                if (Array.isArray(assets) && assets.length > 0) {
                    assets.forEach(asset => {
                        const option = document.createElement('option');
                        option.value = asset;
                        option.textContent = asset;
                        assetSelect.appendChild(option);
                    });
                } else {
                    assetSelect.innerHTML = '<option value="">No assets found</option>';
                }
                
                logMessage('info', `Assets loaded: ${assets?.length || 0} assets`);
            } catch (error) {
                assetSelect.innerHTML = '<option value="">Failed to load assets</option>';
                logMessage('warn', 'Failed to load assets', { error: error.message });
            }
        }

        /**
         * Refresh asset list for active instance - used by Refresh Status button
         * Includes proper error handling and logging
         */
        async function refreshAssetListForActiveInstance() {
            const activeInstance = getActiveInstanceWithMeta();
            if (!activeInstance) {
                logMessage('info', 'Asset refresh skipped - no active instance');
                return;
            }

            logMessage('info', 'Refreshing asset list for active instance', { 
                instance: getDisplayName(activeInstance) 
            });

            try {
                await loadAssetsForActiveInstance();
                logMessage('info', 'Asset list refreshed successfully');
                
            } catch (error) {
                logMessage('error', 'Failed to refresh asset list', { 
                    error: error.message,
                    instance: activeInstance.url 
                });
            }
        }

        /**
         * Enhanced asset input synchronization with debouncing to prevent race conditions
         */
        function syncAssetInputs() {
            const assetSelect = els.assetSelect();
            const assetInput = els.asset();
            
            if (!assetSelect || !assetInput) return;
            
            // Remove existing listeners to prevent duplicates
            const newSelect = assetSelect.cloneNode(true);
            const newInput = assetInput.cloneNode(true);
            assetSelect.parentNode.replaceChild(newSelect, assetSelect);
            assetInput.parentNode.replaceChild(newInput, assetInput);

            let syncTimeout = null;

            // Sync dropdown to input
            newSelect.addEventListener('change', () => {
                if (syncTimeout) clearTimeout(syncTimeout);
                
                syncTimeout = setTimeout(() => {
                    if (newSelect.value && newSelect.value !== newInput.value) {
                        newInput.value = newSelect.value;
                        logMessage('info', 'Asset synced from dropdown', { asset: newSelect.value });
                    }
                }, 100); // Small debounce
            });

            // Sync input to dropdown with debounced typing
            newInput.addEventListener('input', () => {
                if (syncTimeout) clearTimeout(syncTimeout);
                
                syncTimeout = setTimeout(() => {
                    const inputValue = newInput.value.trim();
                    
                    if (inputValue) {
                        // Find matching option in dropdown
                        const matchingOption = Array.from(newSelect.options).find(opt => 
                            opt.value === inputValue
                        );
                        
                        if (matchingOption && newSelect.value !== inputValue) {
                            newSelect.value = inputValue;
                            logMessage('info', 'Asset synced from input', { asset: inputValue });
                        } else if (!matchingOption && newSelect.value !== '') {
                            newSelect.value = ''; // Clear selection if no match
                        }
                    } else if (newSelect.value !== '') {
                        newSelect.value = ''; // Clear selection if input is empty
                    }
                }, 300); // Longer debounce for typing
            });
        }

        // Legacy Helper Functions (Updated for new UI)
        // ===========================================

        /**
         * Update status in console (legacy compatibility)
         * @param {string} message - Status message
         * @param {Object} data - Optional data object
         */
        function updateStatus(message, data = null) {
            const statusText = data ? `${message} ${JSON.stringify(data, null, 2)}` : message;
            const statusElement = els.status();
            if (statusElement) {
                statusElement.textContent = statusText;
            }
        }

        /**
         * Legacy populate list function (updated for new UI)
         */
        async function populateList() {
            renderInstanceList();
            updateOverviewBadges();
        }

        // Event Handlers
        // ==============

        /**
         * Handle adaptive Add button click
         */
        async function handleAddInstance() {
            const baseUrlInput = els.baseUrl();
            if (!baseUrlInput) return;

            const baseUrl = baseUrlInput.value.trim();
            const url = normalizeBaseUrl(baseUrl);

            if (!url) {
                showAddFeedback('Enter a valid URL (e.g., http://127.0.0.1:8081)', 'error');
                return;
            }

            // Check for duplicates
            const instances = getInstances();
            if (instances.includes(url)) {
                showAddFeedback('Instance already exists', 'warning');
                return;
            }

            // Start validation
            showAddFeedback('Checking...', 'warning');
            logMessage('info', 'Add: checking URL', { url });

            try {
                const result = await pingUrlForValidation(url);
                
                if (result.ok) {
                    showAddFeedback(`Ping success (${result.pingMs}ms)`, 'success');
                    logMessage('info', `Ping OK: ${url} (${result.pingMs}ms)`, result.data);
                } else {
                    const errorMsg = result.error || `HTTP ${result.status}`;
                    showAddFeedback('Ping failed', 'warning');
                    logMessage('warn', `Ping FAILED: ${url} (${errorMsg})`);
                }
                
                // Show Add/Skip actions
                toggleAddActions(true, url, result);
                
            } catch (error) {
                showAddFeedback('Ping failed', 'warning');
                logMessage('warn', 'Ping error', { url, error: error.message });
                toggleAddActions(true, url, null);
            }
        }

        /**
         * Handle refresh status button click
         */
        async function handleRefreshStatus() {
            const instances = getInstances();
            
            if (instances.length === 0) {
                logMessage('info', 'Refresh: no instances to check');
                return;
            }

            const environment = window.smartManager?.environment || 'unknown';
            const proxy = window.smartManager?.proxyAvailable || false;
            
            logMessage('info', 'Refresh: starting', { 
                environment, 
                proxy, 
                count: instances.length 
            });

            // Set all to checking
            instances.forEach(url => {
                updateInstanceMeta(url, { lastStatus: 'checking' });
            });
            renderInstanceList();

            // Ping all in parallel with proper status tracking
            const pingPromises = instances.map(async (url) => {
                try {
                    const result = await pingUrlForValidation(url);
                    const isSuccessful = result.ok; // Fixed: was result.success (undefined)
                    updateInstanceMeta(url, { 
                        lastStatus: isSuccessful ? 'success' : 'failed',
                        lastPingMs: result.pingMs || null,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: isSuccessful ? null : result.error,
                        hostName: result.data?.hostName || getInstanceMeta(url).hostName
                    });
                    return isSuccessful;
                } catch (error) {
                    updateInstanceMeta(url, { 
                        lastStatus: 'failed',
                        lastPingMs: null,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: error.message
                    });
                    return false;
                }
            });

            const results = await Promise.allSettled(pingPromises);
            const reachableCount = results.filter(result => 
                result.status === 'fulfilled' && result.value
            ).length;
            
            logMessage('info', 'Refresh: complete', { 
                reachable: reachableCount, 
                total: instances.length,
                proxy 
            });

            renderInstanceList();
            updateOverviewBadges();
            
            // Refresh asset list for active instance to ensure synchronization
            await refreshAssetListForActiveInstance();
            
            // ðŸ”„ CRITICAL FIX: Ensure smart manager is synchronized with latest ping results
            await syncToSmartManager();
        }

        /**
         * Handle reset connections - force complete connection state reset
         */
        async function handleResetConnections() {
            logMessage('info', 'Resetting all connections - forcing complete re-discovery...');
            
            try {
                // Clear any cached connection states in smart manager
                if (window.smartManager) {
                    // Force reset proxy availability check
                    smartManager.proxyAvailable = false;
                    
                    // Force re-detection of environment and proxy
                    const environment = smartManager.detectEnvironment();
                    await smartManager.checkProxyAvailability();
                    
                    logMessage('info', 'Connection reset: environment re-detected', {
                        environment: environment,
                        proxy: smartManager.proxyAvailable
                    });
                    
                    // Force complete re-discovery
                    await smartManager.discoverInstances();
                    
                    // ðŸ”„ CRITICAL FIX: Sync discovery results back to taskpane metadata
                    syncFromSmartManager();
                    
                    logMessage('info', 'Connection reset: instances re-discovered and synced');
                }
                
                // Refresh UI
                renderInstanceList();
                updateOverviewBadges();
                await refreshAssetListForActiveInstance();
                
                logMessage('info', 'Connection reset completed successfully');
                
            } catch (error) {
                logMessage('error', 'Connection reset failed', { error: error.message });
            }
        }

        /**
         * Setup all event listeners for the enhanced UI
         */
        function setupEventListeners() {
            // Add Instance (Adaptive flow)
            const registerBtn = els.register();
            if (registerBtn) {
                registerBtn.addEventListener("click", handleAddInstance);
            }

            // Refresh Status
            const refreshBtn = els.refreshConnections();
            if (refreshBtn) {
                refreshBtn.addEventListener("click", handleRefreshStatus);
            }

            // Reset Connections
            const resetBtn = els.resetConnections();
            if (resetBtn) {
                resetBtn.addEventListener("click", handleResetConnections);
            }

            // Check Summary
            const summaryBtn = els.checkSummary();
            if (summaryBtn) {
                summaryBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateSummary(els.summary(), { error: "No active instance selected" });
                        logMessage('warn', 'Get Summary: No active instance');
                        return;
                    }
                    
                    const displayName = getDisplayName(activeInstance);
                    logMessage('info', 'Getting comprehensive details for active instance', { 
                        instance: displayName,
                        url: activeInstance.url 
                    });
                    
                    // Show loading state
                    updateSummary(els.summary(), { 
                        status: "Loading...",
                        instance: displayName,
                        url: activeInstance.url,
                        timestamp: new Date().toISOString()
                    });
                    
                    try {
                        const [ping, stats, assets] = await Promise.all([
                            foglampPingSmart().catch(e => ({ error: String(e) })),
                            foglampStatisticsSmart().catch(e => ({ error: String(e) })),
                            foglampAssetsSmart().catch(e => ({ error: String(e) }))
                        ]);
                        
                        const summary = { 
                            instance: displayName,
                            url: activeInstance.url,
                            timestamp: new Date().toISOString(),
                            ping, 
                            statistics: stats, 
                            assets 
                        };
                        updateSummary(els.summary(), summary);
                        logMessage('info', 'Instance details retrieved successfully', { instance: displayName });
                        
                    } catch (error) {
                        updateSummary(els.summary(), { 
                            error: error.message,
                            instance: displayName,
                            url: activeInstance.url,
                            timestamp: new Date().toISOString()
                        });
                        logMessage('error', 'Failed to get instance details', { 
                            instance: displayName,
                            error: error.message 
                        });
                    }
                });
            }

            // Export Status  
            const exportStatusBtn = els.writeStatus();
            if (exportStatusBtn) {
                exportStatusBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateStatus("No active instance");
                        logMessage('warn', 'Export Status: no active instance');
                        return;
                    }

                    const instanceName = activeInstance.name || activeInstance.hostName || new URL(activeInstance.url).hostname;
                    const sheetName = `${instanceName} - FogLAMP - Status`;
                    
                    logMessage('info', 'Exporting status to sheet', { instance: instanceName, sheet: sheetName });
                    updateStatus("Exporting FogLAMP status...");
                    
                    try {
                        const [ping, stats, assets] = await Promise.all([
                            foglampPingSmart().catch(e => ({ error: String(e) })),
                            foglampStatisticsSmart().catch(e => ({ error: String(e) })),
                            foglampAssetsSmart().catch(e => ({ error: String(e) }))
                        ]);

                        await Excel.run(async (context) => {
                            const sheet = await ensureWorksheet(context, sheetName);
                            sheet.load("usedRange");
                            await context.sync();
                            
                            // Clear existing content
                            if (sheet.usedRange) {
                                sheet.usedRange.clear();
                                await context.sync();
                            }
                            
                            const start = sheet.getRange("A1");

                            // Write data using simple approach
                            const data = [
                                ["Type", "Data"],
                                ["Instance", instanceName],
                                ["URL", activeInstance.url],
                                ["Timestamp", new Date().toISOString()],
                                ["", ""],
                                ["PING", JSON.stringify(ping, null, 2)],
                                ["", ""],
                                ["STATISTICS", JSON.stringify(stats, null, 2)],
                                ["", ""],
                                ["ASSETS", JSON.stringify(assets, null, 2)]
                            ];

                            // Calculate range size and set values
                            const range = start.getResizedRange(data.length - 1, data[0].length - 1);
                            range.values = data;

                            // Format headers
                            const headerRow = sheet.getRange("A1:B1");
                            headerRow.format.font.bold = true;
                            headerRow.format.fill.color = "#E3F2FD";
                            
                            // Auto-fit columns
                            sheet.getRange("A:B").format.autofitColumns();
                        });

                        updateStatus(`Status exported to sheet '${sheetName}'`);
                        logMessage('info', 'Status exported successfully', { sheet: sheetName });
                        
                    } catch (error) {
                        updateStatus("Failed to export status", { error: error.message });
                        logMessage('error', 'Status export failed', { error: error.message });
                    }
                });
            }

            // Export Asset Readings
            const exportReadingsBtn = els.getReadings();
            if (exportReadingsBtn) {
                exportReadingsBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateStatus("No active instance");
                        logMessage('warn', 'Export Readings: no active instance');
                        return;
                    }

                    const assetSelect = els.assetSelect();
                    const assetInput = els.asset();
                    const asset = (assetSelect?.value || assetInput?.value || "").trim();
                    
                    if (!asset) {
                        updateStatus("Select or enter an asset name");
                        logMessage('warn', 'Export Readings: no asset specified');
                        return;
                    }

                    const datapoint = (els.datapoint()?.value || "").trim();
                    const limit = Math.max(1, Math.min(10000, parseInt(els.limit()?.value || "100", 10)));
                    const skip = Math.max(0, parseInt(els.skip()?.value || "0", 10));
                    const seconds = els.seconds()?.value ? parseInt(els.seconds().value, 10) : -1;
                    const minutes = els.minutes()?.value ? parseInt(els.minutes().value, 10) : -1;
                    const hours = els.hours()?.value ? parseInt(els.hours().value, 10) : -1;
                    const previous = els.previous()?.value ? parseInt(els.previous().value, 10) : -1;
                    
                    // Validate time window usage (only one should be used)
                    const timeParams = [seconds, minutes, hours].filter(v => v > 0);
                    if (timeParams.length > 1) {
                        updateStatus("Error: Use only one time window parameter (seconds, minutes, or hours)");
                        logMessage('warn', 'Export Readings: multiple time window parameters specified');
                        return;
                    }
                    
                    const instanceName = activeInstance.name || activeInstance.hostName || new URL(activeInstance.url).hostname;
                    const sheetName = `${instanceName} - asset - ${asset}`;
                    
                    logMessage('info', 'Exporting asset readings', { 
                        instance: instanceName, 
                        asset, 
                        datapoint: datapoint || 'all',
                        limit,
                        skip,
                        timeWindow: timeParams.length > 0 ? { seconds, minutes, hours } : 'none',
                        previous 
                    });
                    updateStatus("Fetching asset readings...");
                    
                    try {
                        // Build parameters for the smart API call
                        const apiParams = {
                            asset,
                            datapoint: datapoint || '',
                            limit: timeParams.length > 0 ? -1 : limit,  // Disable limit when using time window
                            skip: timeParams.length > 0 ? -1 : skip,    // Disable skip when using time window
                            seconds: seconds > 0 ? seconds : -1,
                            minutes: minutes > 0 ? minutes : -1,
                            hours: hours > 0 ? hours : -1,
                            previous: previous > 0 ? previous : -1
                        };
                        
                        const data = await foglampAssetReadingsSmartWithParams(apiParams);
                        const { header, rows } = flattenReadings(data);
                        
                        await Excel.run(async (context) => {
                            const sheet = await ensureWorksheet(context, sheetName);
                            const start = sheet.getRange("A1");
                            
                            writeTable(start, rows, header);
                            
                            // Format headers
                            if (header.length > 0) {
                                // Safe column letter calculation for Excel ranges
                                function getColumnLetter(colIndex) {
                                    let result = '';
                                    while (colIndex >= 0) {
                                        result = String.fromCharCode(65 + (colIndex % 26)) + result;
                                        colIndex = Math.floor(colIndex / 26) - 1;
                                    }
                                    return result;
                                }
                                
                                const headerRange = sheet.getRange(`A1:${getColumnLetter(header.length - 1)}1`);
                                headerRange.format.font.bold = true;
                                headerRange.format.fill.color = "#E3F2FD";
                            }
                            
                            start.format.autofitColumns();
                        });

                        updateStatus(`Asset readings exported to sheet '${sheetName}'`);
                        logMessage('info', 'Asset readings exported successfully', { 
                            sheet: sheetName, 
                            rows: rows.length 
                        });
                        
                    } catch (error) {
                        updateStatus("Failed to fetch readings", { error: error.message });
                        logMessage('error', 'Asset readings export failed', { 
                            asset, 
                            error: error.message 
                        });
                    }
                });
            }

            // Asset input synchronization
            syncAssetInputs();

            // Console clear button
            const clearConsoleBtn = document.getElementById('clear-console');
            if (clearConsoleBtn) {
                clearConsoleBtn.addEventListener('click', clearConsole);
            }
        }

        /**
         * Initialize UI components and load initial data
         */
        async function initializeUI() {
            // Initial render
            renderInstanceList();
            updateOverviewBadges();
            
            // Load assets for active instance
            await loadAssetsForActiveInstance();
            
            // Update connection status display
            updateConnectionStatus();
        }

        function normalizeBaseUrl(input) {
            if (!input) return "";
            let url = input.trim();
            if (!/^https?:\/\//i.test(url)) {
                url = "http://" + url;
            }
            url = url.replace(/\/$/, "");
            return url;
        }

        function updateStatus(msg, obj) {
            const out = [msg];
            if (obj !== undefined) {
                try {
                    out.push(JSON.stringify(obj, null, 2));
                } catch (e) {
                    out.push(String(obj));
                }
            }
            els.status().textContent = out.join("\n");
            // Auto-scroll console content to bottom when new logs arrive
            const container = document.querySelector('.console-content');
            if (container) container.scrollTop = container.scrollHeight;
        }

        function updateSummary(preEl, payload) {
            try {
                preEl.textContent = JSON.stringify(payload, null, 2);
            } catch (e) {
                preEl.textContent = String(payload);
            }
        }

        async function populateList() {
            const sel = els.list();
            while (sel.firstChild) sel.removeChild(sel.firstChild);
            const instances = getInstances();
            const active = getActiveInstance();
            // Move active to front
            const ordered = [...instances].sort((a,b) => (a===active? -1 : b===active? 1 : 0));
            // Ping each to derive status dots
            for (const u of ordered) {
                let ok = false;
                try {
                    const res = await fetch(u + "/foglamp/ping", { method: "GET" });
                    ok = res.ok;
                } catch (e) { ok = false; }
                const opt = document.createElement("option");
                opt.value = u;
                const dot = ok ? "ðŸŸ¢" : "âšª"; // green = ok, white/grey = not reachable
                opt.textContent = `${dot} ${u}${u===active? " (active)" : ""}`;
                sel.appendChild(opt);
            }
            // Ensure active selected by default
            if (active) sel.value = active;
        }

        // Note: FogLAMP API calls now use smart connection manager (smart-connection.js)
        // Functions: foglampPingSmart, foglampStatisticsSmart, foglampAssetsSmart, foglampAssetReadingsSmart

        // Excel helpers
        async function ensureWorksheet(context, name) {
            const sheets = context.workbook.worksheets;
            let sheet;
            try {
                sheet = sheets.getItem(name);
                sheet.load("name");
                await context.sync();
            } catch (e) {
                sheet = sheets.add(name);
                await context.sync();
            }
            return sheet;
        }

        function writeTable(rangeObj, rows, header) {
            if (header && header.length) {
                rangeObj.getCell(0, 0).getResizedRange(0, header.length - 1).values = [header];
                if (rows.length) {
                    rangeObj.getOffsetRange(1, 0).getResizedRange(rows.length - 1, header.length - 1).values = rows;
                }
            } else if (rows.length) {
                rangeObj.getResizedRange(rows.length - 1, rows[0].length - 1).values = rows;
            }
        }

        function toKeyValueRows(obj) {
            return Object.keys(obj || {}).map(k => [k, stringifyCell(obj[k])]);
        }

        function stringifyCell(v) {
            if (v === null || v === undefined) return "";
            if (typeof v === "object") return JSON.stringify(v);
            return String(v);
        }

        function flattenAssets(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const header = ["asset", "count"];
            const rows = list.map(it => [it.asset || it.name || "", it.count != null ? it.count : ""]);
            return { header, rows };
        }

        function flattenStatistics(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const header = ["key", "value"];
            const rows = list.map(it => [it.key || it.statistic || it.name || "", it.value != null ? it.value : ""]);
            return { header, rows };
        }

        function flattenReadings(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const dpSet = new Set();
            list.forEach(it => {
                const reading = it.reading || it.readings || {};
                Object.keys(reading).forEach(k => dpSet.add(k));
            });
            const datapoints = Array.from(dpSet);
            const header = ["timestamp", "asset", ...datapoints];
            const rows = list.map(it => {
                const r = it.reading || it.readings || {};
                return [it.timestamp || "", it.asset || "", ...datapoints.map(k => r[k] != null ? r[k] : "")];
            });
            return { header, rows };
        }

        // ðŸ”„ CRITICAL FIX: Bidirectional Status Sync Functions
        // Prevents dual status system desync between taskpane metadata and smart manager
        
        /**
         * Sync taskpane metadata with smart manager accessibility status
         * Call this after smart manager discovery to ensure UI reflects smart manager state
         */
        function syncFromSmartManager() {
            if (!window.smartManager) return;
            
            try {
                const smartInstances = smartManager.availableInstances;
                const registeredUrls = getInstances();
                
                let syncCount = 0;
                
                registeredUrls.forEach(url => {
                    // Find matching smart manager instance by URL
                    const smartInstance = Array.from(smartInstances.values()).find(inst => 
                        inst.url === url || inst.name.includes(url)
                    );
                    
                    if (smartInstance) {
                        const currentMeta = getInstanceMeta(url);
                        const smartStatus = smartInstance.accessible ? 'success' : 'failed';
                        
                        // Only sync if there's a meaningful difference
                        if (currentMeta.lastStatus !== smartStatus) {
                            updateInstanceMeta(url, {
                                lastStatus: smartStatus,
                                hostName: smartInstance.health || currentMeta.hostName,
                                lastCheckedAt: new Date().toISOString(),
                                lastError: smartInstance.accessible ? null : 'Not accessible via smart manager'
                            });
                            syncCount++;
                        }
                    }
                });
                
                if (syncCount > 0) {
                    logMessage('info', `Synced ${syncCount} instances from smart manager to taskpane metadata`);
                    renderInstanceList();
                    updateOverviewBadges();
                }
                
            } catch (error) {
                logMessage('warn', 'Failed to sync from smart manager', { error: error.message });
            }
        }
        
        /**
         * Force smart manager to re-discover instances
         * Call this after taskpane metadata updates to ensure smart manager reflects latest state
         */
        async function syncToSmartManager() {
            if (!window.smartManager) return;
            
            try {
                logMessage('info', 'Forcing smart manager re-discovery...');
                await smartManager.discoverInstances();
                logMessage('info', 'Smart manager synchronized successfully');
                
                // Also sync back to ensure consistency
                syncFromSmartManager();
                
            } catch (error) {
                logMessage('warn', 'Smart manager sync failed', { error: error.message });
            }
        }

        // Smart Connection Management with enhanced error handling
        async function initializeSmartConnections() {
            updateEnvironmentInfo('Detecting environment...');
            updateConnectionSummary('Initializing...');

            try {
                console.log('ðŸš€ Starting smart connection initialization...');
                console.log('ðŸ“‹ Available functions:', {
                    getInstances: typeof getInstances,
                    addInstance: typeof addInstance,
                    smartManager: typeof smartManager
                });

                // Detect environment
                const environment = smartManager.detectEnvironment();
                console.log('ðŸ” Environment detection result:', environment);
                updateEnvironmentInfo(`Environment: ${environment === 'web' ? 'Excel Web ðŸŒ' : 'Excel Desktop ðŸ“±'}`);
                logMessage('info', `Environment detected: ${environment}`);

                // Get registered instances count before discovery
                const registeredInstances = getInstances();
                logMessage('info', `Found ${registeredInstances.length} registered instances`);

                if (registeredInstances.length === 0) {
                    updateConnectionSummary('No instances registered - Add instances to get started');
                    logMessage('info', 'No instances registered - user needs to add instances');
                    
                    // Still initialize UI components
                    await populateSmartInstances();
                    
                    console.log('âœ… Smart connection initialization complete (no instances)');
                    return;
                }

                // Discover available instances
                updateConnectionSummary('Discovering instances...');
                console.log('ðŸ” Starting instance discovery...');
                logMessage('info', 'Starting instance discovery...');
                
                const instances = await smartManager.discoverInstances();
                console.log('âœ… Instance discovery complete:', instances.length, 'instances found');
                logMessage('info', `Instance discovery complete: ${instances.length}/${registeredInstances.length} accessible`);
                
                // ðŸ”„ CRITICAL FIX: Sync smart manager discovery results back to taskpane metadata
                syncFromSmartManager();
                
                updateConnectionSummary('Discovery complete');
                updateConnectionStatus();
                
                // Auto-populate instances in the list
                await populateSmartInstances();
                
                console.log('âœ… Smart connection initialization complete');
                logMessage('info', 'Smart connection initialization complete');
                
            } catch (error) {
                console.error('âŒ Smart connection initialization failed:', error);
                logMessage('error', 'Smart connection initialization failed', { error: error.message });
                updateConnectionSummary('Initialization failed: ' + error.message);
                
                // Still try to initialize UI even if discovery fails
                try {
                    await populateSmartInstances();
                } catch (uiError) {
                    console.error('UI initialization also failed:', uiError);
                }
            }
        }

        function updateEnvironmentInfo(message) {
            const el = document.getElementById('environment-info');
            if (el) el.textContent = message;
        }

        function updateConnectionSummary(message) {
            const el = document.getElementById('connection-summary');
            if (el) el.textContent = message;
        }

        function updateConnectionStatus() {
            const status = smartManager.getConnectionStatus();
            updateConnectionSummary(status.message);
            
            // Show proxy guidance if needed
            const proxyGuidance = document.getElementById('proxy-guidance');
            if (proxyGuidance) {
                proxyGuidance.style.display = status.suggestion && status.suggestion.includes('proxy') ? 'block' : 'none';
            }

            // Update header color based on status
            const header = document.getElementById('connection-status-header');
            if (header) {
                const summary = header.querySelector('.muted');
                if (summary) {
                    if (status.status === 'success') {
                        summary.style.color = '#16a34a'; // green
                        summary.textContent = '(all connected)';
                    } else if (status.status === 'partial') {
                        summary.style.color = '#ea580c'; // orange  
                        summary.textContent = '(partial)';
                    } else {
                        summary.style.color = '#dc2626'; // red
                        summary.textContent = '(connection issues)';
                    }
                }
            }
        }

        async function populateSmartInstances() {
            // Just refresh the UI list with what's already registered by users
            // Don't auto-add instances - let users register them manually
            renderInstanceList();
            updateOverviewBadges();
        }

        // Enhanced Event Wiring & Initialization
        document.addEventListener("DOMContentLoaded", async () => {
            try {
                logMessage('info', 'FogLAMP DataLink starting...');
                
                // Initialize smart connection manager
                await initializeSmartConnections();
                
                // Setup event listeners for new UI
                setupEventListeners();
                
                // Initialize UI components
                await initializeUI();
                
                logMessage('info', 'FogLAMP DataLink initialized successfully');
                
            } catch (error) {
                logMessage('error', 'Failed to initialize FogLAMP DataLink', { error: error.message });
                console.error('Initialization error:', error);
            }

            // Console drag-to-resize
            const consoleEl = document.querySelector('.app-console');
            const resizer = document.querySelector('.console-resizer');
            let startY = 0;
            let startH = 28; // Start collapsed
            let isDragging = false;
            
            function setConsoleHeight(height) {
                const minHeight = 28; // Collapsed height (header only)
                const maxHeight = Math.min(500, window.innerHeight * 0.7); // Max 70% of viewport
                const newHeight = Math.max(minHeight, Math.min(maxHeight, height));
                document.documentElement.style.setProperty('--console-height', newHeight + 'px');
                return newHeight;
            }
            
            function onMouseMove(e) {
                if (!isDragging) return;
                const dy = startY - e.clientY; // Dragging up increases height
                const newHeight = startH + dy;
                setConsoleHeight(newHeight);
            }
            
            function onMouseUp() {
                isDragging = false;
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                document.body.style.userSelect = '';
            }
            
            resizer.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                // Safe height calculation with fallback
                const heightValue = getComputedStyle(document.documentElement).getPropertyValue('--console-height');
                const currentHeight = heightValue ? parseInt(heightValue.replace('px', '')) : 28;
                startH = isNaN(currentHeight) ? 28 : currentHeight;
                document.body.style.userSelect = 'none'; // Prevent text selection while dragging
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            });
            
            // Initialize console height
            setConsoleHeight(28);
        });

    </script>
</body>

</html>
