<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FogLAMP Data Link</title>
    <link rel="stylesheet" href="src/styles/taskpane.css">
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <script type="text/javascript" src="smart-connection.js?v=4"></script>
    <script type="module" src="src/js/main.js"></script>
</head>

<body>
    <!-- Scrollable Interaction Area -->
    <div class="app-body">
        <!-- Overview / Connection Status -->
        <details open>
            <summary>Overview</summary>
        <div class="section-content">
                <div class="row" style="margin-bottom: 12px;">
                    <div id="environment-badge" class="badge">Detecting...</div>
                    <div id="connectivity-badge" class="badge">Checking...</div>
                    <div id="proxy-badge" class="badge">Unknown</div>
                </div>
                <div class="row" style="margin-bottom: 12px;">
                    <div id="active-instance-display" class="small muted">No active instance</div>
                </div>
            <div class="row">
                <div class="stack">
                    <button id="refresh-connections" type="button" title="Re-scan all instances and update status">Refresh Status</button>
                    <button id="reset-connections" type="button" title="Reset all connections and force complete re-discovery">Reset Connections</button>
                </div>
            </div>
                <div id="proxy-guidance" class="feedback-area warning" style="display: none;">
                    <strong>💡 Excel Web detected:</strong> Run <code>node simple-proxy.js</code> locally to access private network instances.
            </div>
        </div>
    </details>

        <!-- FogLAMP Instances (Merged) -->
    <details open>
            <summary>FogLAMP Instances</summary>
        <div class="section-content">
                <!-- Add Instance -->
            <div class="row">
                    <label for="fl-base-url">Add Instance <span class="info" title="Enter FogLAMP URL (e.g., http://127.0.0.1:8081)"><img src="icons/info-icon-16.png" alt="info" /></span></label>
                <div class="stack">
                        <input id="fl-base-url" type="text" placeholder="http://127.0.0.1:8081" />
                        <button id="fl-register" type="button" title="Validate and add this FogLAMP instance">Add</button>
                    </div>
                </div>
                
                <!-- Adaptive Add Feedback -->
                <div id="fl-add-feedback" class="feedback-area" style="display: none;"></div>
                <div id="fl-add-actions" class="row" style="display: none; gap: 6px; margin-top: 6px;">
                    <button id="fl-add-confirm" type="button" class="primary">Add</button>
                    <button id="fl-add-skip" type="button">Skip</button>
            </div>

                <!-- Instance List -->
                <div class="row" style="margin-top: 16px;">
                    <div id="instances-container">
                        <div class="empty-state" id="empty-instances">
                            No instances yet. Add a FogLAMP URL to begin.
                        </div>
                    </div>
                </div>

                <!-- Instance Actions Summary -->
                <div class="row" style="margin-top: 12px;">
            <details>
                        <summary>Instance Summary</summary>
                <div class="section-content">
                    <div class="row">
                                <button id="fl-check-summary" type="button" title="Get comprehensive status (ping + statistics + assets) for active instance">Get Active Instance Details</button>
                    </div>
                    <pre id="fl-summary" class="status-pre"></pre>
                </div>
            </details>
                </div>
        </div>
    </details>

        <!-- Data Actions -->
    <details>
            <summary>Data Actions <span class="muted small">(Excel export)</span></summary>
        <div class="section-content">
                <div class="stack" style="margin-bottom: 12px;">
                    <!-- Export Status -->
                    <div style="border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px;">
            <div class="row">
                            <strong>Export Status</strong>
                            <div class="small muted">Ping, statistics, assets → formatted sheet</div>
            </div>
                        <div class="row">
                            <button id="fl-write-status" type="button" title="Export comprehensive status to Excel sheet">Export Status to Sheet</button>
        </div>
                    </div>

                    <!-- Export Asset Readings -->
                    <div style="border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px;">
            <div class="row">
                            <strong>Export Asset Readings</strong>
                            <div class="small muted">Asset data → formatted sheet</div>
            </div>
            <div class="row">
                            <div class="stack">
                                <select id="fl-asset-select" title="Select asset from available assets">
                                    <option value="">Loading assets...</option>
                                </select>
                                <input id="fl-asset" type="text" placeholder="or type asset name" />
                            </div>
            </div>
            <div class="row">
                            <div class="stack">
                                <input id="fl-datapoint" type="text" placeholder="datapoint (optional)" />
                                <input id="fl-limit" type="number" min="1" max="10000" value="100" placeholder="limit" style="max-width: 100px;" />
                            </div>
            </div>
            <div class="row">
                            <input id="fl-skip" type="number" min="0" value="0" placeholder="skip (pagination)" style="max-width: 120px;" />
            </div>
            <div class="row">
                            <label class="small">Time window (use only one)</label>
                <div class="stack">
                    <input id="fl-seconds" type="number" min="1" placeholder="seconds" />
                    <input id="fl-minutes" type="number" min="1" placeholder="minutes" />
                    <input id="fl-hours" type="number" min="1" placeholder="hours" />
                </div>
            </div>
            <div class="row">
                            <input id="fl-previous" type="number" min="1" placeholder="previous (for historical)" />
            </div>
            <div class="row">
                            <button id="fl-get-readings" type="button" title="Export asset readings to Excel sheet">Get Readings</button>
            </div>
        </div>
                </div>
            </div>
        </details>
    </div>

    <!-- Draggable Console -->
    <div class="app-console">
        <div class="console-resizer" title="Drag to resize console"></div>
        <div class="console-header">
            <div class="console-title">Console <span class="muted small">live logs & messages</span></div>
            <div>
                <button id="clear-console" style="background: transparent; border: 1px solid #4b5563; color: #e5e7eb; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; margin-right: 8px;" title="Clear console logs">Clear</button>
            <span class="live-badge" title="Status updates appear here in real time">LIVE</span>
            </div>
        </div>
        <div class="console-content">
            <pre id="fl-status" class="status-pre"></pre>
        </div>
    </div>
    <script>
        // Initialize Office.js
        Office.onReady(function (info) { });

        // Add a click event listener to the button
        document.getElementById("run-btn") && document.getElementById("run-btn").addEventListener("click", run);

        // Based on 'Basic API call' sample from ScriptLab
        async function run() {
            await Excel.run(async (context) => {
                const range = context.workbook.getSelectedRange();
                range.format.fill.color = "yellow";
                range.load("address");

                await context.sync();

                const sheets = context.workbook.worksheets;
                sheets.getItem("Sheet1").getRange("A1").values = [["The selected address was " + range.address + "."]];
            });
        }

        // =============================
        // FogLAMP DataLink prototype JS
        // =============================

        // Configuration constants (loaded from modules)
        // Available as: window.FogLAMP.config.STORAGE_KEYS, etc.
        const STORAGE_KEYS = window.FogLAMP?.config.STORAGE_KEYS || {
            INSTANCES: "FOGLAMP_INSTANCES",
            ACTIVE: "FOGLAMP_ACTIVE"
        };

        // UI element selectors (loaded from modules)  
        // Available as: window.FogLAMP.elements
        const els = window.FogLAMP?.elements || {
            // Fallback element selectors if modules not loaded yet
            environmentBadge: () => document.getElementById("environment-badge"),
            connectivityBadge: () => document.getElementById("connectivity-badge"),
            proxyBadge: () => document.getElementById("proxy-badge"),
            activeInstanceDisplay: () => document.getElementById("active-instance-display"),
            refreshConnections: () => document.getElementById("refresh-connections"),
            resetConnections: () => document.getElementById("reset-connections"),
            proxyGuidance: () => document.getElementById("proxy-guidance"),
            baseUrl: () => document.getElementById("fl-base-url"),
            register: () => document.getElementById("fl-register"),
            addFeedback: () => document.getElementById("fl-add-feedback"),
            addActions: () => document.getElementById("fl-add-actions"),
            addConfirm: () => document.getElementById("fl-add-confirm"),
            addSkip: () => document.getElementById("fl-add-skip"),
            instancesContainer: () => document.getElementById("instances-container"),
            emptyInstances: () => document.getElementById("empty-instances"),
            checkSummary: () => document.getElementById("fl-check-summary"),
            summary: () => document.getElementById("fl-summary"),
            writeStatus: () => document.getElementById("fl-write-status"),
            assetSelect: () => document.getElementById("fl-asset-select"),
            asset: () => document.getElementById("fl-asset"),
            datapoint: () => document.getElementById("fl-datapoint"),
            limit: () => document.getElementById("fl-limit"),
            skip: () => document.getElementById("fl-skip"),
            seconds: () => document.getElementById("fl-seconds"),
            minutes: () => document.getElementById("fl-minutes"),
            hours: () => document.getElementById("fl-hours"),
            previous: () => document.getElementById("fl-previous"),
            getReadings: () => document.getElementById("fl-get-readings"),
            status: () => document.getElementById("fl-status")
        };

        // Enhanced Instance Storage System
        // =================================
        // This system manages both URL list (for backward compatibility) 
        // and rich metadata for each instance

        // Utility functions (loaded from modules)
        // Available as: window.FogLAMP.utils.getDisplayName, etc.
        const getDisplayName = window.FogLAMP?.utils.getDisplayName || function(instance) {
            // Fallback implementation
            if (instance?.name) return instance.name;
            if (instance?.hostName) return instance.hostName;
            try {
                return new URL(instance.url).hostname;
            } catch (e) {
                return instance.url?.replace(/^https?:\/\//, '').split('/')[0] || 'Unknown Instance';
            }
        };

        // Enhanced storage keys (loaded from modules)
        const ENHANCED_STORAGE_KEYS = window.FogLAMP?.config.ENHANCED_STORAGE_KEYS || {
            ...STORAGE_KEYS,
            INSTANCE_METADATA: 'foglamp_instance_metadata'
        };

        // Status constants (loaded from modules)  
        const INSTANCE_STATUS = window.FogLAMP?.config.INSTANCE_STATUS || {
            SUCCESS: 'success',
            FAILED: 'failed', 
            CHECKING: 'checking',
            UNKNOWN: 'unknown'
        };

        /**
         * Instance metadata structure:
         * {
         *   url: string,
         *   name?: string,           // Optional user-provided name
         *   hostName?: string,       // From FogLAMP /ping response
         *   lastStatus: 'success'|'failed'|'checking'|'unknown',
         *   lastPingMs?: number,     // Response time in milliseconds
         *   lastCheckedAt?: string,  // ISO timestamp
         *   addedAt: string,         // ISO timestamp when first added
         *   lastError?: string       // Last error message if any
         * }
         */

        // ===============================================
        // Instance Storage Functions (Extracted to Module)
        // ===============================================
        // These functions are now loaded from src/js/core/storage.js
        // Available as: window.FogLAMP.storage.getInstanceMetadata(), window.getInstanceMetadata(), etc.
        // Functions loaded via src/js/main.js: 
        // - getInstanceMetadata, saveInstanceMetadata
        // - getInstanceMeta, updateInstanceMeta  
        // - getEnhancedInstances, getInstances
        // - addInstance, removeInstance
        // - getActiveInstance, setActiveInstance
        // - getActiveInstanceWithMeta, normalizeBaseUrl

        // Legacy Storage Functions (Now in Module)
        // =======================================
        // All storage functions moved to src/js/core/storage.js
        // Available globally via window.getInstances(), window.addInstance(), etc.
        // See main.js for complete list of exposed functions

        // Global function exposure now handled by src/js/main.js
        // Functions available via window.getInstances(), window.addInstance(), etc.

        // Enhanced UI Management Functions
        // ===============================

        /**
         * Update overview badges with current system status
         */
        function updateOverviewBadges() {
            const environment = window.smartManager?.environment || 'unknown';
            const proxy = window.smartManager?.proxyAvailable || false;
            const instances = getEnhancedInstances();
            const reachableCount = instances.filter(i => i.lastStatus === 'success').length;
            
            // Debug logging for status calculation
            if (instances.length > 0) {
                const statusBreakdown = instances.reduce((acc, inst) => {
                    acc[inst.lastStatus || 'unknown'] = (acc[inst.lastStatus || 'unknown'] || 0) + 1;
                    return acc;
                }, {});
                console.log(`🔍 Status calculation: ${reachableCount}/${instances.length} connected`, statusBreakdown);
            }
            
            // Environment badge
            const envBadge = els.environmentBadge();
            if (envBadge) {
                envBadge.textContent = environment === 'web' ? 'Excel Web' : 
                                     environment === 'desktop' ? 'Excel Desktop' : 'Unknown';
                envBadge.className = `badge ${environment === 'web' ? 'warning' : 'success'}`;
            }

            // Connectivity badge with enhanced status handling
            const connBadge = els.connectivityBadge();
            if (connBadge) {
                const total = instances.length;
                if (total === 0) {
                    connBadge.textContent = 'No instances';
                    connBadge.className = 'badge error';
                } else if (reachableCount === total) {
                    connBadge.textContent = `All ${total} connected`;
                    connBadge.className = 'badge success';
                } else if (reachableCount > 0) {
                    connBadge.textContent = `${reachableCount} of ${total} connected`;
                    connBadge.className = 'badge warning';
                } else {
                    connBadge.textContent = `0 of ${total} connected`;
                    connBadge.className = 'badge error';
                }
            }

            // Proxy badge with scenario-specific handling
            const proxyBadge = els.proxyBadge();
            if (proxyBadge) {
                if (environment === 'desktop') {
                    proxyBadge.textContent = 'N/A';
                    proxyBadge.className = 'badge default';
                } else {
                    // Web environment
                    proxyBadge.textContent = proxy ? 'Proxy: Running' : 'Proxy: Not Running';
                    proxyBadge.className = `badge ${proxy ? 'success' : 'warning'}`;
                }
            }

            // Active instance display with enhanced messages
            const activeDisplay = els.activeInstanceDisplay();
            if (activeDisplay) {
                const active = getActiveInstanceWithMeta();
                if (active) {
                    const displayName = active.name || active.hostName || new URL(active.url).hostname;
                    activeDisplay.textContent = `Active: ${displayName}`;
                    activeDisplay.className = 'small';
                } else if (instances.length === 0) {
                    activeDisplay.textContent = 'Add instances to get started';
                    activeDisplay.className = 'small muted';
                } else {
                    activeDisplay.textContent = 'No active instance - click "Set Active"';
                    activeDisplay.className = 'small muted';
                }
            }

            // Enhanced proxy guidance logic
            const guidance = els.proxyGuidance();
            if (guidance) {
                // Only show for web environment with no proxy AND non-localhost instances exist
                const hasRemoteInstances = instances.some(i => 
                    !i.url.includes('127.0.0.1') && !i.url.includes('localhost')
                );
                const shouldShow = environment === 'web' && !proxy && hasRemoteInstances;
                guidance.style.display = shouldShow ? 'block' : 'none';
            }
        }

        /**
         * Render enhanced instance list with metadata and actions
         */
        function renderInstanceList() {
            const container = els.instancesContainer();
            const emptyState = els.emptyInstances();
            if (!container || !emptyState) return;

            const instances = getEnhancedInstances();
            const activeUrl = getActiveInstance();

            // Clear container
            container.innerHTML = '';

            if (instances.length === 0) {
                container.appendChild(emptyState);
                return;
            }

            // Sort instances: Active first, then successful (by ping time), then failed
            const sortedInstances = [...instances].sort((a, b) => {
                if (a.url === activeUrl) return -1;
                if (b.url === activeUrl) return 1;
                if (a.lastStatus === 'success' && b.lastStatus !== 'success') return -1;
                if (b.lastStatus === 'success' && a.lastStatus !== 'success') return 1;
                if (a.lastStatus === 'success' && b.lastStatus === 'success') {
                    return (a.lastPingMs || 999999) - (b.lastPingMs || 999999);
                }
                return a.url.localeCompare(b.url);
            });

            // Render each instance
            sortedInstances.forEach(instance => {
                const row = document.createElement('div');
                row.className = `instance-row ${instance.url === activeUrl ? 'active' : ''}`;

                // Status dot
                const dot = document.createElement('div');
                dot.className = `status-dot ${instance.lastStatus || 'unknown'}`;

                // Instance info
                const info = document.createElement('div');
                info.className = 'instance-info';

                const name = document.createElement('div');
                name.className = 'instance-name';
                name.textContent = getDisplayName(instance);
                
                // Add editable name functionality
                name.addEventListener('dblclick', () => editInstanceName(instance.url, name));

                const url = document.createElement('div');
                url.className = 'instance-url';
                url.textContent = instance.url;

                info.appendChild(name);
                info.appendChild(url);

                // Action buttons
                const actions = document.createElement('div');
                actions.className = 'instance-actions';

                // Active badge for active instance
                if (instance.url === activeUrl) {
                    const activeBadge = document.createElement('span');
                    activeBadge.className = 'badge active';
                    activeBadge.textContent = 'Active';
                    activeBadge.style.marginRight = '8px';
                    actions.appendChild(activeBadge);
                }

                // Ping time badge
                if (instance.lastPingMs) {
                    const pingBadge = document.createElement('span');
                    pingBadge.className = 'small muted';
                    pingBadge.textContent = `${instance.lastPingMs}ms`;
                    pingBadge.style.marginRight = '8px';
                    actions.appendChild(pingBadge);
                }

                // Action buttons
                if (instance.url !== activeUrl) {
                    const setActiveBtn = document.createElement('button');
                    setActiveBtn.textContent = 'Set Active';
                    setActiveBtn.className = 'primary';
                    setActiveBtn.onclick = () => setInstanceActive(instance.url);
                    actions.appendChild(setActiveBtn);
                }

                const pingBtn = document.createElement('button');
                pingBtn.textContent = 'Ping';
                pingBtn.onclick = () => pingInstance(instance.url);
                actions.appendChild(pingBtn);

                // Removed confusing per-instance Statistics button - use main "Get Summary" instead

                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => removeInstanceWithConfirm(instance.url);
                actions.appendChild(removeBtn);

                // Assemble row
                row.appendChild(dot);
                row.appendChild(info);
                row.appendChild(actions);

                container.appendChild(row);
            });
        }

        /**
         * Edit instance name inline
         * @param {string} url - Instance URL
         * @param {Element} nameElement - Name element to edit
         */
        function editInstanceName(url, nameElement) {
            const currentName = getInstanceMeta(url).name || '';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.width = '100%';
            input.style.fontSize = '14px';
            input.style.fontWeight = '600';

            const save = () => {
                const newName = input.value.trim();
                updateInstanceMeta(url, { name: newName });
                renderInstanceList();
                updateOverviewBadges();
                logMessage('info', 'Instance name updated', { url, name: newName || '(cleared)' });
            };

            const cancel = () => {
                renderInstanceList();
            };

            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') save();
                if (e.key === 'Escape') cancel();
            });

            nameElement.replaceWith(input);
            input.focus();
            input.select();
        }

        // Console Logging System
        // =====================

        /**
         * Log structured message to console with enhanced UI features
         * @param {string} level - Log level: 'info', 'warn', 'error'
         * @param {string} message - Log message
         * @param {Object} details - Optional details object
         */
        // Console & Logging Functions (Now in Module)
        // ==========================================
        // Console functions moved to src/js/ui/console.js
        // Available globally via window.logMessage(), window.clearConsole(), etc.
        // See main.js for complete list of exposed functions

        // Instance Management Functions
        // ============================

        /**
         * Ping specific instance and update its status
         * @param {string} url - Instance URL to ping
         */
        async function pingInstance(url) {
            updateInstanceMeta(url, { lastStatus: 'checking' });
            renderInstanceList();
            
            const startTime = performance.now();
            logMessage('info', 'Ping started', { url });

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(`${url}/foglamp/ping`, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                clearTimeout(timeoutId);
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                
                if (response.ok) {
                    const data = await response.json();
                    updateInstanceMeta(url, {
                        lastStatus: 'success',
                        lastPingMs: pingMs,
                        lastCheckedAt: new Date().toISOString(),
                        hostName: data.hostName || getInstanceMeta(url).hostName,
                        lastError: null // Clear previous errors on success
                    });
                    logMessage('info', `Individual ping SUCCESS: ${url} (${pingMs}ms)`, data);
                } else {
                    updateInstanceMeta(url, {
                        lastStatus: 'failed',
                        lastPingMs: pingMs,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: `HTTP ${response.status}`
                    });
                    logMessage('warn', `Individual ping FAILED: ${url} (HTTP ${response.status})`);
                }
            } catch (error) {
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                updateInstanceMeta(url, {
                    lastStatus: 'failed',
                    lastPingMs: null, // No meaningful ping time for network errors
                    lastCheckedAt: new Date().toISOString(),
                    lastError: error.message
                });
                logMessage('warn', `Individual ping NETWORK ERROR: ${url} (${error.message})`);
            }
            
            renderInstanceList();
            updateOverviewBadges();
            
            // 🔧 CRITICAL FIX: Sync individual ping results with smart connection manager
            // This prevents the dual status system desync bug where individual ping works
            // but Get Summary/Export functions fail due to smart manager thinking instances are inaccessible
            await syncToSmartManager();
        }

        /**
         * Set instance as active
         * @param {string} url - Instance URL to set as active
         */
        async function setInstanceActive(url) {
            setActiveInstance(url);
            logMessage('info', 'Active instance changed', { url });
            renderInstanceList();
            updateOverviewBadges();
            
            // Load assets for the new active instance
            await loadAssetsForActiveInstance();
        }

        /**
         * Remove instance with confirmation
         * @param {string} url - Instance URL to remove
         */
        function removeInstanceWithConfirm(url) {
            const instance = getInstanceMeta(url);
            const displayName = getDisplayName(instance);
            
            logMessage('info', 'Remove requested', { url, displayName });
            
            if (confirm(`Remove instance "${displayName}"?\n\nURL: ${url}`)) {
                const removed = removeInstance(url);
                if (removed) {
                    logMessage('info', 'Instance removed successfully', { url, name: displayName });
                    renderInstanceList();
                    updateOverviewBadges();
                } else {
                    logMessage('warn', 'Failed to remove instance', { url });
                }
            } else {
                logMessage('info', 'Remove cancelled by user', { url });
            }
        }

        /**
         * Get statistics for specific instance with proper error handling
         * @param {string} url - Instance URL
         */
        async function getInstanceStatistics(url) {
            logMessage('info', 'Fetching statistics', { url });
            
            try {
                // Set as active temporarily to use smart API functions
                const originalActive = getActiveInstance();
                setActiveInstance(url);
                
                const stats = await foglampStatisticsSmart();
                
                // Display in summary area
                const summaryElement = els.summary();
                if (summaryElement) {
                    updateSummary(summaryElement, { statistics: stats });
                }
                
                // Restore original active
                if (originalActive && originalActive !== url) {
                    setActiveInstance(originalActive);
                    renderInstanceList();
                }
                
                logMessage('info', 'Statistics retrieved successfully', { url });
                
            } catch (error) {
                logMessage('error', 'Failed to get statistics', { url, error: error.message });
                
                // Display error in summary area
                const summaryElement = els.summary();
                if (summaryElement) {
                    updateSummary(summaryElement, { 
                        error: `Statistics failed for ${url}: ${error.message}` 
                    });
                }
                
                // Update main status
                updateStatus('Statistics failed:', { error: error.message });
            }
        }

        /**
         * Enhanced asset readings API call with all parameters
         * @param {Object} params - API parameters object
         * @returns {Promise} Asset readings data
         */
        async function foglampAssetReadingsSmartWithParams(params) {
            // Use the existing smart API but with all the parameters
            return await foglampAssetReadingsSmart(
                params.asset,
                params.datapoint,
                params.limit,
                params.skip,
                params.seconds,
                params.minutes, 
                params.hours,
                params.previous
            );
        }

        // Adaptive Add Flow Implementation
        // ===============================

        /**
         * Show add feedback message
         * @param {string} message - Feedback message
         * @param {string} type - Message type: 'success', 'warning', 'error'
         */
        function showAddFeedback(message, type = 'success') {
            const feedback = els.addFeedback();
            if (feedback) {
                feedback.textContent = message;
                feedback.className = `feedback-area ${type}`;
                feedback.style.display = 'block';
            }
        }

        /**
         * Hide add feedback
         */
        function hideAddFeedback() {
            const feedback = els.addFeedback();
            if (feedback) {
                feedback.style.display = 'none';
            }
        }

        /**
         * Show/hide add action buttons
         * @param {boolean} show - Whether to show buttons
         * @param {string} url - URL being added
         * @param {Object} pingResult - Ping result data
         */
        function toggleAddActions(show, url = '', pingResult = null) {
            const actions = els.addActions();
            const confirmBtn = els.addConfirm();
            const skipBtn = els.addSkip();
            
            if (!actions || !confirmBtn || !skipBtn) return;
            
            actions.style.display = show ? 'flex' : 'none';
            
            if (show) {
                // Configure confirm button
                confirmBtn.onclick = async () => {
                    await confirmAddInstance(url, pingResult);
                    hideAddFeedback();
                    toggleAddActions(false);
                };
                
                // Configure skip button
                skipBtn.onclick = () => {
                    logMessage('info', 'Add skipped', { url });
                    hideAddFeedback();
                    toggleAddActions(false);
                };
            }
        }

        /**
         * Confirm and add instance with metadata
         * @param {string} url - Instance URL
         * @param {Object} pingResult - Ping result data
         */
        async function confirmAddInstance(url, pingResult) {
            const options = {
                lastStatus: pingResult?.ok ? 'success' : 'failed',
                lastPingMs: pingResult?.pingMs,
                hostName: pingResult?.data?.hostName,
                lastCheckedAt: new Date().toISOString()
            };
            
            const added = addInstance(url, options);
            
            if (added) {
                logMessage('info', 'Instance added successfully', { 
                    url, 
                    hostName: options.hostName,
                    status: options.lastStatus 
                });
                
                // Clear input
                const input = els.baseUrl();
                if (input) input.value = '';
                
                // Update UI
                renderInstanceList();
                updateOverviewBadges();
                
                // Load assets for new active instance
                await loadAssetsForActiveInstance();
            } else {
                logMessage('warn', 'Instance already exists', { url });
            }
        }

        /**
         * Ping URL with timeout for validation
         * @param {string} url - URL to ping
         * @param {number} timeoutMs - Timeout in milliseconds
         * @returns {Promise} Ping result
         */
        async function pingUrlForValidation(url, timeoutMs = 3000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            const startTime = performance.now();
            
            try {
                const response = await fetch(`${url}/foglamp/ping`, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    return { ok: true, pingMs, data, status: response.status };
                } else {
                    return { ok: false, pingMs, status: response.status };
                }
            } catch (error) {
                const endTime = performance.now();
                const pingMs = Math.round(endTime - startTime);
                clearTimeout(timeoutId);
                return { ok: false, pingMs, error: error.message };
            }
        }

        // Asset Management Functions
        // =========================

        /**
         * Load assets for the active instance
         */
        async function loadAssetsForActiveInstance() {
            const assetSelect = els.assetSelect();
            if (!assetSelect) return;

            const activeInstance = getActiveInstance();
            if (!activeInstance) {
                assetSelect.innerHTML = '<option value="">No active instance</option>';
                return;
            }

            assetSelect.innerHTML = '<option value="">Loading assets...</option>';
            
            try {
                const assets = await foglampAssetsSmart();
                
                // Clear and populate dropdown
                assetSelect.innerHTML = '<option value="">Select asset...</option>';
                
                if (Array.isArray(assets) && assets.length > 0) {
                    assets.forEach(asset => {
                        const option = document.createElement('option');
                        option.value = asset;
                        option.textContent = asset;
                        assetSelect.appendChild(option);
                    });
                } else {
                    assetSelect.innerHTML = '<option value="">No assets found</option>';
                }
                
                logMessage('info', `Assets loaded: ${assets?.length || 0} assets`);
            } catch (error) {
                assetSelect.innerHTML = '<option value="">Failed to load assets</option>';
                logMessage('warn', 'Failed to load assets', { error: error.message });
            }
        }

        /**
         * Refresh asset list for active instance - used by Refresh Status button
         * Includes proper error handling and logging
         */
        async function refreshAssetListForActiveInstance() {
            const activeInstance = getActiveInstanceWithMeta();
            if (!activeInstance) {
                logMessage('info', 'Asset refresh skipped - no active instance');
                return;
            }

            logMessage('info', 'Refreshing asset list for active instance', { 
                instance: getDisplayName(activeInstance) 
            });

            try {
                await loadAssetsForActiveInstance();
                logMessage('info', 'Asset list refreshed successfully');
                
            } catch (error) {
                logMessage('error', 'Failed to refresh asset list', { 
                    error: error.message,
                    instance: activeInstance.url 
                });
            }
        }

        /**
         * Enhanced asset input synchronization with debouncing to prevent race conditions
         */
        function syncAssetInputs() {
            const assetSelect = els.assetSelect();
            const assetInput = els.asset();
            
            if (!assetSelect || !assetInput) return;
            
            // Remove existing listeners to prevent duplicates
            const newSelect = assetSelect.cloneNode(true);
            const newInput = assetInput.cloneNode(true);
            assetSelect.parentNode.replaceChild(newSelect, assetSelect);
            assetInput.parentNode.replaceChild(newInput, assetInput);

            let syncTimeout = null;

            // Sync dropdown to input
            newSelect.addEventListener('change', () => {
                if (syncTimeout) clearTimeout(syncTimeout);
                
                syncTimeout = setTimeout(() => {
                    if (newSelect.value && newSelect.value !== newInput.value) {
                        newInput.value = newSelect.value;
                        logMessage('info', 'Asset synced from dropdown', { asset: newSelect.value });
                    }
                }, 100); // Small debounce
            });

            // Sync input to dropdown with debounced typing
            newInput.addEventListener('input', () => {
                if (syncTimeout) clearTimeout(syncTimeout);
                
                syncTimeout = setTimeout(() => {
                    const inputValue = newInput.value.trim();
                    
                    if (inputValue) {
                        // Find matching option in dropdown
                        const matchingOption = Array.from(newSelect.options).find(opt => 
                            opt.value === inputValue
                        );
                        
                        if (matchingOption && newSelect.value !== inputValue) {
                            newSelect.value = inputValue;
                            logMessage('info', 'Asset synced from input', { asset: inputValue });
                        } else if (!matchingOption && newSelect.value !== '') {
                            newSelect.value = ''; // Clear selection if no match
                        }
                    } else if (newSelect.value !== '') {
                        newSelect.value = ''; // Clear selection if input is empty
                    }
                }, 300); // Longer debounce for typing
            });
        }

        // Legacy Helper Functions (Updated for new UI)
        // ===========================================

        /**
         * Update status in console (legacy compatibility)
         * @param {string} message - Status message
         * @param {Object} data - Optional data object
         */
        function updateStatus(message, data = null) {
            const statusText = data ? `${message} ${JSON.stringify(data, null, 2)}` : message;
            const statusElement = els.status();
            if (statusElement) {
                statusElement.textContent = statusText;
            }
        }

        /**
         * Legacy populate list function (updated for new UI)
         */
        async function populateList() {
            renderInstanceList();
            updateOverviewBadges();
        }

        // Event Handlers
        // ==============

        /**
         * Handle adaptive Add button click
         */
        async function handleAddInstance() {
            const baseUrlInput = els.baseUrl();
            if (!baseUrlInput) return;

            const baseUrl = baseUrlInput.value.trim();
            const url = normalizeBaseUrl(baseUrl);

            if (!url) {
                showAddFeedback('Enter a valid URL (e.g., http://127.0.0.1:8081)', 'error');
                return;
            }

            // Check for duplicates
            const instances = getInstances();
            if (instances.includes(url)) {
                showAddFeedback('Instance already exists', 'warning');
                return;
            }

            // Start validation
            showAddFeedback('Checking...', 'warning');
            logMessage('info', 'Add: checking URL', { url });

            try {
                const result = await pingUrlForValidation(url);
                
                if (result.ok) {
                    showAddFeedback(`Ping success (${result.pingMs}ms)`, 'success');
                    logMessage('info', `Ping OK: ${url} (${result.pingMs}ms)`, result.data);
                } else {
                    const errorMsg = result.error || `HTTP ${result.status}`;
                    showAddFeedback('Ping failed', 'warning');
                    logMessage('warn', `Ping FAILED: ${url} (${errorMsg})`);
                }
                
                // Show Add/Skip actions
                toggleAddActions(true, url, result);
                
            } catch (error) {
                showAddFeedback('Ping failed', 'warning');
                logMessage('warn', 'Ping error', { url, error: error.message });
                toggleAddActions(true, url, null);
            }
        }

        /**
         * Handle refresh status button click
         */
        async function handleRefreshStatus() {
            const instances = getInstances();
            
            if (instances.length === 0) {
                logMessage('info', 'Refresh: no instances to check');
                return;
            }

            const environment = window.smartManager?.environment || 'unknown';
            const proxy = window.smartManager?.proxyAvailable || false;
            
            logMessage('info', 'Refresh: starting', { 
                environment, 
                proxy, 
                count: instances.length 
            });

            // Set all to checking
            instances.forEach(url => {
                updateInstanceMeta(url, { lastStatus: 'checking' });
            });
            renderInstanceList();

            // Ping all in parallel with proper status tracking
            const pingPromises = instances.map(async (url) => {
                try {
                    const result = await pingUrlForValidation(url);
                    const isSuccessful = result.ok; // Fixed: was result.success (undefined)
                    updateInstanceMeta(url, { 
                        lastStatus: isSuccessful ? 'success' : 'failed',
                        lastPingMs: result.pingMs || null,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: isSuccessful ? null : result.error,
                        hostName: result.data?.hostName || getInstanceMeta(url).hostName
                    });
                    return isSuccessful;
                } catch (error) {
                    updateInstanceMeta(url, { 
                        lastStatus: 'failed',
                        lastPingMs: null,
                        lastCheckedAt: new Date().toISOString(),
                        lastError: error.message
                    });
                    return false;
                }
            });

            const results = await Promise.allSettled(pingPromises);
            const reachableCount = results.filter(result => 
                result.status === 'fulfilled' && result.value
            ).length;
            
            logMessage('info', 'Refresh: complete', { 
                reachable: reachableCount, 
                total: instances.length,
                proxy 
            });

            renderInstanceList();
            updateOverviewBadges();
            
            // Refresh asset list for active instance to ensure synchronization
            await refreshAssetListForActiveInstance();
            
            // 🔄 CRITICAL FIX: Ensure smart manager is synchronized with latest ping results
            await syncToSmartManager();
        }

        /**
         * Handle reset connections - force complete connection state reset
         */
        async function handleResetConnections() {
            logMessage('info', 'Resetting all connections - forcing complete re-discovery...');
            
            try {
                // Clear any cached connection states in smart manager
                if (window.smartManager) {
                    // Force reset proxy availability check
                    smartManager.proxyAvailable = false;
                    
                    // Force re-detection of environment and proxy
                    const environment = smartManager.detectEnvironment();
                    await smartManager.checkProxyAvailability();
                    
                    logMessage('info', 'Connection reset: environment re-detected', {
                        environment: environment,
                        proxy: smartManager.proxyAvailable
                    });
                    
                    // Force complete re-discovery
                    await smartManager.discoverInstances();
                    
                    // 🔄 CRITICAL FIX: Sync discovery results back to taskpane metadata
                    syncFromSmartManager();
                    
                    logMessage('info', 'Connection reset: instances re-discovered and synced');
                }
                
                // Refresh UI
                renderInstanceList();
                updateOverviewBadges();
                await refreshAssetListForActiveInstance();
                
                logMessage('info', 'Connection reset completed successfully');
                
            } catch (error) {
                logMessage('error', 'Connection reset failed', { error: error.message });
            }
        }

        /**
         * Setup all event listeners for the enhanced UI
         */
        function setupEventListeners() {
            // Add Instance (Adaptive flow)
            const registerBtn = els.register();
            if (registerBtn) {
                registerBtn.addEventListener("click", handleAddInstance);
            }

            // Refresh Status
            const refreshBtn = els.refreshConnections();
            if (refreshBtn) {
                refreshBtn.addEventListener("click", handleRefreshStatus);
            }

            // Reset Connections
            const resetBtn = els.resetConnections();
            if (resetBtn) {
                resetBtn.addEventListener("click", handleResetConnections);
            }

            // Check Summary
            const summaryBtn = els.checkSummary();
            if (summaryBtn) {
                summaryBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateSummary(els.summary(), { error: "No active instance selected" });
                        logMessage('warn', 'Get Summary: No active instance');
                        return;
                    }
                    
                    const displayName = getDisplayName(activeInstance);
                    logMessage('info', 'Getting comprehensive details for active instance', { 
                        instance: displayName,
                        url: activeInstance.url 
                    });
                    
                    // Show loading state
                    updateSummary(els.summary(), { 
                        status: "Loading...",
                        instance: displayName,
                        url: activeInstance.url,
                        timestamp: new Date().toISOString()
                    });
                    
                    try {
                        const [ping, stats, assets] = await Promise.all([
                            foglampPingSmart().catch(e => ({ error: String(e) })),
                            foglampStatisticsSmart().catch(e => ({ error: String(e) })),
                            foglampAssetsSmart().catch(e => ({ error: String(e) }))
                        ]);
                        
                        const summary = { 
                            instance: displayName,
                            url: activeInstance.url,
                            timestamp: new Date().toISOString(),
                            ping, 
                            statistics: stats, 
                            assets 
                        };
                        updateSummary(els.summary(), summary);
                        logMessage('info', 'Instance details retrieved successfully', { instance: displayName });
                        
                    } catch (error) {
                        updateSummary(els.summary(), { 
                            error: error.message,
                            instance: displayName,
                            url: activeInstance.url,
                            timestamp: new Date().toISOString()
                        });
                        logMessage('error', 'Failed to get instance details', { 
                            instance: displayName,
                            error: error.message 
                        });
                    }
                });
            }

            // Export Status  
            const exportStatusBtn = els.writeStatus();
            if (exportStatusBtn) {
                exportStatusBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateStatus("No active instance");
                        logMessage('warn', 'Export Status: no active instance');
                        return;
                    }

                    const instanceName = activeInstance.name || activeInstance.hostName || new URL(activeInstance.url).hostname;
                    const sheetName = `${instanceName} - FogLAMP - Status`;
                    
                    logMessage('info', 'Exporting status to sheet', { instance: instanceName, sheet: sheetName });
                    updateStatus("Exporting FogLAMP status...");
                    
                    try {
                        const [ping, stats, assets] = await Promise.all([
                            foglampPingSmart().catch(e => ({ error: String(e) })),
                            foglampStatisticsSmart().catch(e => ({ error: String(e) })),
                            foglampAssetsSmart().catch(e => ({ error: String(e) }))
                        ]);

                        await Excel.run(async (context) => {
                            const sheet = await ensureWorksheet(context, sheetName);
                            sheet.load("usedRange");
                            await context.sync();
                            
                            // Clear existing content
                            if (sheet.usedRange) {
                                sheet.usedRange.clear();
                                await context.sync();
                            }
                            
                            const start = sheet.getRange("A1");

                            // Write data using simple approach
                            const data = [
                                ["Type", "Data"],
                                ["Instance", instanceName],
                                ["URL", activeInstance.url],
                                ["Timestamp", new Date().toISOString()],
                                ["", ""],
                                ["PING", JSON.stringify(ping, null, 2)],
                                ["", ""],
                                ["STATISTICS", JSON.stringify(stats, null, 2)],
                                ["", ""],
                                ["ASSETS", JSON.stringify(assets, null, 2)]
                            ];

                            // Calculate range size and set values
                            const range = start.getResizedRange(data.length - 1, data[0].length - 1);
                            range.values = data;

                            // Format headers
                            const headerRow = sheet.getRange("A1:B1");
                            headerRow.format.font.bold = true;
                            headerRow.format.fill.color = "#E3F2FD";
                            
                            // Auto-fit columns
                            sheet.getRange("A:B").format.autofitColumns();
                        });

                        updateStatus(`Status exported to sheet '${sheetName}'`);
                        logMessage('info', 'Status exported successfully', { sheet: sheetName });
                        
                    } catch (error) {
                        updateStatus("Failed to export status", { error: error.message });
                        logMessage('error', 'Status export failed', { error: error.message });
                    }
                });
            }

            // Export Asset Readings
            const exportReadingsBtn = els.getReadings();
            if (exportReadingsBtn) {
                exportReadingsBtn.addEventListener("click", async () => {
                    const activeInstance = getActiveInstanceWithMeta();
                    if (!activeInstance) {
                        updateStatus("No active instance");
                        logMessage('warn', 'Export Readings: no active instance');
                        return;
                    }

                    const assetSelect = els.assetSelect();
                    const assetInput = els.asset();
                    const asset = (assetSelect?.value || assetInput?.value || "").trim();
                    
                    if (!asset) {
                        updateStatus("Select or enter an asset name");
                        logMessage('warn', 'Export Readings: no asset specified');
                        return;
                    }

                    const datapoint = (els.datapoint()?.value || "").trim();
                    const limit = Math.max(1, Math.min(10000, parseInt(els.limit()?.value || "100", 10)));
                    const skip = Math.max(0, parseInt(els.skip()?.value || "0", 10));
                    const seconds = els.seconds()?.value ? parseInt(els.seconds().value, 10) : -1;
                    const minutes = els.minutes()?.value ? parseInt(els.minutes().value, 10) : -1;
                    const hours = els.hours()?.value ? parseInt(els.hours().value, 10) : -1;
                    const previous = els.previous()?.value ? parseInt(els.previous().value, 10) : -1;
                    
                    // Validate time window usage (only one should be used)
                    const timeParams = [seconds, minutes, hours].filter(v => v > 0);
                    if (timeParams.length > 1) {
                        updateStatus("Error: Use only one time window parameter (seconds, minutes, or hours)");
                        logMessage('warn', 'Export Readings: multiple time window parameters specified');
                        return;
                    }
                    
                    const instanceName = activeInstance.name || activeInstance.hostName || new URL(activeInstance.url).hostname;
                    const sheetName = `${instanceName} - asset - ${asset}`;
                    
                    logMessage('info', 'Exporting asset readings', { 
                        instance: instanceName, 
                        asset, 
                        datapoint: datapoint || 'all',
                        limit,
                        skip,
                        timeWindow: timeParams.length > 0 ? { seconds, minutes, hours } : 'none',
                        previous 
                    });
                    updateStatus("Fetching asset readings...");
                    
                    try {
                        // Build parameters for the smart API call
                        const apiParams = {
                            asset,
                            datapoint: datapoint || '',
                            limit: timeParams.length > 0 ? -1 : limit,  // Disable limit when using time window
                            skip: timeParams.length > 0 ? -1 : skip,    // Disable skip when using time window
                            seconds: seconds > 0 ? seconds : -1,
                            minutes: minutes > 0 ? minutes : -1,
                            hours: hours > 0 ? hours : -1,
                            previous: previous > 0 ? previous : -1
                        };
                        
                        const data = await foglampAssetReadingsSmartWithParams(apiParams);
                        const { header, rows } = flattenReadings(data);
                        
                        await Excel.run(async (context) => {
                            const sheet = await ensureWorksheet(context, sheetName);
                            const start = sheet.getRange("A1");
                            
                            writeTable(start, rows, header);
                            
                            // Format headers
                            if (header.length > 0) {
                                // Use modular utility function for Excel column letters
                                const getColumnLetter = window.FogLAMP?.utils.getColumnLetter || function(colIndex) {
                                    let result = '';
                                    while (colIndex >= 0) {
                                        result = String.fromCharCode(65 + (colIndex % 26)) + result;
                                        colIndex = Math.floor(colIndex / 26) - 1;
                                    }
                                    return result;
                                };
                                
                                const headerRange = sheet.getRange(`A1:${getColumnLetter(header.length - 1)}1`);
                                headerRange.format.font.bold = true;
                                headerRange.format.fill.color = "#E3F2FD";
                            }
                            
                            start.format.autofitColumns();
                        });

                        updateStatus(`Asset readings exported to sheet '${sheetName}'`);
                        logMessage('info', 'Asset readings exported successfully', { 
                            sheet: sheetName, 
                            rows: rows.length 
                        });
                        
                    } catch (error) {
                        updateStatus("Failed to fetch readings", { error: error.message });
                        logMessage('error', 'Asset readings export failed', { 
                            asset, 
                            error: error.message 
                        });
                    }
                });
            }

            // Asset input synchronization
            syncAssetInputs();

            // Console clear button
            const clearConsoleBtn = document.getElementById('clear-console');
            if (clearConsoleBtn) {
                clearConsoleBtn.addEventListener('click', clearConsole);
            }
        }

        /**
         * Initialize UI components and load initial data
         */
        async function initializeUI() {
            // Initial render
            renderInstanceList();
            updateOverviewBadges();
            
            // Load assets for active instance
            await loadAssetsForActiveInstance();
            
            // Update connection status display
            updateConnectionStatus();
        }

        // normalizeBaseUrl now available from src/js/core/storage.js

        function updateStatus(msg, obj) {
            const out = [msg];
            if (obj !== undefined) {
                try {
                    out.push(JSON.stringify(obj, null, 2));
                } catch (e) {
                    out.push(String(obj));
                }
            }
            els.status().textContent = out.join("\n");
            // Auto-scroll console content to bottom when new logs arrive
            const container = document.querySelector('.console-content');
            if (container) container.scrollTop = container.scrollHeight;
        }

        // updateSummary now available from src/js/ui/console.js

        async function populateList() {
            const sel = els.list();
            while (sel.firstChild) sel.removeChild(sel.firstChild);
            const instances = getInstances();
            const active = getActiveInstance();
            // Move active to front
            const ordered = [...instances].sort((a,b) => (a===active? -1 : b===active? 1 : 0));
            // Ping each to derive status dots
            for (const u of ordered) {
                let ok = false;
                try {
                    const res = await fetch(u + "/foglamp/ping", { method: "GET" });
                    ok = res.ok;
                } catch (e) { ok = false; }
                const opt = document.createElement("option");
                opt.value = u;
                const dot = ok ? "🟢" : "⚪"; // green = ok, white/grey = not reachable
                opt.textContent = `${dot} ${u}${u===active? " (active)" : ""}`;
                sel.appendChild(opt);
            }
            // Ensure active selected by default
            if (active) sel.value = active;
        }

        // Note: FogLAMP API calls now use smart connection manager (smart-connection.js)
        // Functions: foglampPingSmart, foglampStatisticsSmart, foglampAssetsSmart, foglampAssetReadingsSmart

        // Excel helpers
        async function ensureWorksheet(context, name) {
            const sheets = context.workbook.worksheets;
            let sheet;
            try {
                sheet = sheets.getItem(name);
                sheet.load("name");
                await context.sync();
            } catch (e) {
                sheet = sheets.add(name);
                await context.sync();
            }
            return sheet;
        }

        function writeTable(rangeObj, rows, header) {
            if (header && header.length) {
                rangeObj.getCell(0, 0).getResizedRange(0, header.length - 1).values = [header];
                if (rows.length) {
                    rangeObj.getOffsetRange(1, 0).getResizedRange(rows.length - 1, header.length - 1).values = rows;
                }
            } else if (rows.length) {
                rangeObj.getResizedRange(rows.length - 1, rows[0].length - 1).values = rows;
            }
        }

        function toKeyValueRows(obj) {
            return Object.keys(obj || {}).map(k => [k, stringifyCell(obj[k])]);
        }

        function stringifyCell(v) {
            if (v === null || v === undefined) return "";
            if (typeof v === "object") return JSON.stringify(v);
            return String(v);
        }

        function flattenAssets(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const header = ["asset", "count"];
            const rows = list.map(it => [it.asset || it.name || "", it.count != null ? it.count : ""]);
            return { header, rows };
        }

        function flattenStatistics(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const header = ["key", "value"];
            const rows = list.map(it => [it.key || it.statistic || it.name || "", it.value != null ? it.value : ""]);
            return { header, rows };
        }

        function flattenReadings(list) {
            if (!Array.isArray(list)) return { header: ["raw_json"], rows: [[JSON.stringify(list)]] };
            const dpSet = new Set();
            list.forEach(it => {
                const reading = it.reading || it.readings || {};
                Object.keys(reading).forEach(k => dpSet.add(k));
            });
            const datapoints = Array.from(dpSet);
            const header = ["timestamp", "asset", ...datapoints];
            const rows = list.map(it => {
                const r = it.reading || it.readings || {};
                return [it.timestamp || "", it.asset || "", ...datapoints.map(k => r[k] != null ? r[k] : "")];
            });
            return { header, rows };
        }

        // 🔄 CRITICAL FIX: Bidirectional Status Sync Functions
        // Prevents dual status system desync between taskpane metadata and smart manager
        
        /**
         * Sync taskpane metadata with smart manager accessibility status
         * Call this after smart manager discovery to ensure UI reflects smart manager state
         */
        function syncFromSmartManager() {
            if (!window.smartManager) return;
            
            try {
                const smartInstances = smartManager.availableInstances;
                const registeredUrls = getInstances();
                
                let syncCount = 0;
                
                registeredUrls.forEach(url => {
                    // Find matching smart manager instance by URL
                    const smartInstance = Array.from(smartInstances.values()).find(inst => 
                        inst.url === url || inst.name.includes(url)
                    );
                    
                    if (smartInstance) {
                        const currentMeta = getInstanceMeta(url);
                        const smartStatus = smartInstance.accessible ? 'success' : 'failed';
                        
                        // Only sync if there's a meaningful difference
                        if (currentMeta.lastStatus !== smartStatus) {
                            updateInstanceMeta(url, {
                                lastStatus: smartStatus,
                                hostName: smartInstance.health || currentMeta.hostName,
                                lastCheckedAt: new Date().toISOString(),
                                lastError: smartInstance.accessible ? null : 'Not accessible via smart manager'
                            });
                            syncCount++;
                        }
                    }
                });
                
                if (syncCount > 0) {
                    logMessage('info', `Synced ${syncCount} instances from smart manager to taskpane metadata`);
                    renderInstanceList();
                    updateOverviewBadges();
                }
                
            } catch (error) {
                logMessage('warn', 'Failed to sync from smart manager', { error: error.message });
            }
        }
        
        /**
         * Force smart manager to re-discover instances
         * Call this after taskpane metadata updates to ensure smart manager reflects latest state
         */
        async function syncToSmartManager() {
            if (!window.smartManager) return;
            
            try {
                logMessage('info', 'Forcing smart manager re-discovery...');
                await smartManager.discoverInstances();
                logMessage('info', 'Smart manager synchronized successfully');
                
                // Also sync back to ensure consistency
                syncFromSmartManager();
                
            } catch (error) {
                logMessage('warn', 'Smart manager sync failed', { error: error.message });
            }
        }

        // Smart Connection Management with enhanced error handling
        async function initializeSmartConnections() {
            updateEnvironmentInfo('Detecting environment...');
            updateConnectionSummary('Initializing...');

            try {
                console.log('🚀 Starting smart connection initialization...');
                console.log('📋 Available functions:', {
                    getInstances: typeof getInstances,
                    addInstance: typeof addInstance,
                    smartManager: typeof smartManager
                });

                // Detect environment
                const environment = smartManager.detectEnvironment();
                console.log('🔍 Environment detection result:', environment);
                updateEnvironmentInfo(`Environment: ${environment === 'web' ? 'Excel Web 🌐' : 'Excel Desktop 📱'}`);
                logMessage('info', `Environment detected: ${environment}`);

                // Get registered instances count before discovery
                const registeredInstances = getInstances();
                logMessage('info', `Found ${registeredInstances.length} registered instances`);

                if (registeredInstances.length === 0) {
                    updateConnectionSummary('No instances registered - Add instances to get started');
                    logMessage('info', 'No instances registered - user needs to add instances');
                    
                    // Still initialize UI components
                    await populateSmartInstances();
                    
                    console.log('✅ Smart connection initialization complete (no instances)');
                    return;
                }

                // Discover available instances
                updateConnectionSummary('Discovering instances...');
                console.log('🔍 Starting instance discovery...');
                logMessage('info', 'Starting instance discovery...');
                
                const instances = await smartManager.discoverInstances();
                console.log('✅ Instance discovery complete:', instances.length, 'instances found');
                logMessage('info', `Instance discovery complete: ${instances.length}/${registeredInstances.length} accessible`);
                
                // 🔄 CRITICAL FIX: Sync smart manager discovery results back to taskpane metadata
                syncFromSmartManager();
                
                updateConnectionSummary('Discovery complete');
                updateConnectionStatus();
                
                // Auto-populate instances in the list
                await populateSmartInstances();
                
                console.log('✅ Smart connection initialization complete');
                logMessage('info', 'Smart connection initialization complete');
                
            } catch (error) {
                console.error('❌ Smart connection initialization failed:', error);
                logMessage('error', 'Smart connection initialization failed', { error: error.message });
                updateConnectionSummary('Initialization failed: ' + error.message);
                
                // Still try to initialize UI even if discovery fails
                try {
                    await populateSmartInstances();
                } catch (uiError) {
                    console.error('UI initialization also failed:', uiError);
                }
            }
        }

        function updateEnvironmentInfo(message) {
            const el = document.getElementById('environment-info');
            if (el) el.textContent = message;
        }

        function updateConnectionSummary(message) {
            const el = document.getElementById('connection-summary');
            if (el) el.textContent = message;
        }

        function updateConnectionStatus() {
            const status = smartManager.getConnectionStatus();
            updateConnectionSummary(status.message);
            
            // Show proxy guidance if needed
            const proxyGuidance = document.getElementById('proxy-guidance');
            if (proxyGuidance) {
                proxyGuidance.style.display = status.suggestion && status.suggestion.includes('proxy') ? 'block' : 'none';
            }

            // Update header color based on status
            const header = document.getElementById('connection-status-header');
            if (header) {
                const summary = header.querySelector('.muted');
                if (summary) {
                    if (status.status === 'success') {
                        summary.style.color = '#16a34a'; // green
                        summary.textContent = '(all connected)';
                    } else if (status.status === 'partial') {
                        summary.style.color = '#ea580c'; // orange  
                        summary.textContent = '(partial)';
                    } else {
                        summary.style.color = '#dc2626'; // red
                        summary.textContent = '(connection issues)';
                    }
                }
            }
        }

        async function populateSmartInstances() {
            // Just refresh the UI list with what's already registered by users
            // Don't auto-add instances - let users register them manually
            renderInstanceList();
            updateOverviewBadges();
        }

        // Enhanced Event Wiring & Initialization
        document.addEventListener("DOMContentLoaded", async () => {
            try {
                logMessage('info', 'FogLAMP DataLink starting...');
                
                // Initialize smart connection manager
                await initializeSmartConnections();
                
                // Setup event listeners for new UI
                setupEventListeners();
                
                // Initialize UI components
                await initializeUI();
                
                logMessage('info', 'FogLAMP DataLink initialized successfully');
                
            } catch (error) {
                logMessage('error', 'Failed to initialize FogLAMP DataLink', { error: error.message });
                console.error('Initialization error:', error);
            }

            // Console drag-to-resize functionality moved to src/js/ui/console.js
            // Initialization handled by consoleManager.initialize()
        });

    </script>
</body>

</html>
